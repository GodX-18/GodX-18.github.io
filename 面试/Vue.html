<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.8" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.31" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://godx-18.github.io/%E9%9D%A2%E8%AF%95/Vue.html"><meta property="og:site_name" content="烜"><meta property="og:title" content="Vue"><meta property="og:description" content="Vue 的设计模式 介绍一下 MVVM 模式和 MVC 模式有什么区别？ MVVM 模式是一种软件架构设计模式，它将应用程序分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。模型负责处理数据和业务逻辑，视图负责显示用户界面，视图模型负责连接视图和模型，并实现数据绑定和命令模式。MVVM 模式的目的是实现视图和模型的解耦..."><meta property="og:type" content="article"><meta property="og:image" content="https://cn.vuejs.org/assets/lifecycle_zh-CN.FtDDVyNA.png"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-04-14T07:18:18.000Z"><meta property="article:author" content="GodX"><meta property="article:tag" content="Vue"><meta property="article:published_time" content="2023-05-22T00:00:00.000Z"><meta property="article:modified_time" content="2024-04-14T07:18:18.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Vue","image":["https://cn.vuejs.org/assets/lifecycle_zh-CN.FtDDVyNA.png"],"datePublished":"2023-05-22T00:00:00.000Z","dateModified":"2024-04-14T07:18:18.000Z","author":[{"@type":"Person","name":"GodX","url":"https://github.com/GodX-18"}]}</script><title>Vue | 烜</title><meta name="description" content="Vue 的设计模式 介绍一下 MVVM 模式和 MVC 模式有什么区别？ MVVM 模式是一种软件架构设计模式，它将应用程序分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。模型负责处理数据和业务逻辑，视图负责显示用户界面，视图模型负责连接视图和模型，并实现数据绑定和命令模式。MVVM 模式的目的是实现视图和模型的解耦...">
    <link rel="preload" href="/assets/style-CyXSxgyD.css" as="style"><link rel="stylesheet" href="/assets/style-CyXSxgyD.css">
    <link rel="modulepreload" href="/assets/app-oXp7PBbS.js"><link rel="modulepreload" href="/assets/Vue.html-Dy-h_m68.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="route-link vp-brand" href="/"><img class="vp-nav-logo" src="/s.svg" alt><!----><span class="vp-site-name hide-in-pad">烜</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/%E5%A4%A7%E5%89%8D%E7%AB%AF/Nodejs%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/01-Node%E5%9F%BA%E7%A1%80.html" aria-label="大前端"><span class="font-icon icon iconfont icon-qianduan" style=""></span>大前端<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/%E6%A1%88%E4%BE%8B.html" aria-label="算法"><span class="font-icon icon iconfont icon-suanfaku" style=""></span>算法<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/%E9%98%85%E8%AF%BB/" aria-label="阅读"><span class="font-icon icon iconfont icon-yuedu" style=""></span>阅读<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/%E9%9D%A2%E8%AF%95/HTML.html" aria-label="面试"><span class="font-icon icon iconfont icon-interview" style=""></span>面试<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="语言"><span class="title"><span class="font-icon icon iconfont icon-duoyuyan" style=""></span>语言</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/%E8%AF%AD%E8%A8%80/TypeScript/" aria-label="TypeScript"><span class="font-icon icon iconfont icon-typescript" style=""></span>TypeScript<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" aria-label="项目管理"><span class="font-icon icon iconfont icon-xiangmuguanli" style=""></span>项目管理<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/NPDP/" aria-label="NPDP"><span class="font-icon icon iconfont icon-chanpinjingli" style=""></span>NPDP<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/%E5%81%A5%E8%BA%AB/" aria-label="健身"><span class="font-icon icon iconfont icon-jianshen" style=""></span>健身<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="其它"><span class="title"><span class="font-icon icon iconfont icon-qita" style=""></span>其它</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/%E5%85%B6%E5%AE%83/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" aria-label="设计模式"><!---->设计模式<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E5%85%B6%E5%AE%83/%E8%AF%95%E9%AA%8C%E5%9C%BA/" aria-label="试验场"><!---->试验场<!----></a></li></ul></button></div></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><!----><div class="nav-item hide-in-mobile"><button type="button" class="outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!--[--><button type="button" class="search-pro-button" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="search-pro-placeholder">搜索</div><div class="search-pro-key-hints"><kbd class="search-pro-key">Ctrl</kbd><kbd class="search-pro-key">K</kbd></div></button><!--]--><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E9%9D%A2%E8%AF%95/HTML.html" aria-label="HTML"><span class="font-icon icon iconfont icon-HTML" style=""></span>HTML<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E9%9D%A2%E8%AF%95/CSS.html" aria-label="CSS"><span class="font-icon icon iconfont icon-CSS" style=""></span>CSS<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E9%9D%A2%E8%AF%95/JavaScript.html" aria-label="JavaScript"><span class="font-icon icon iconfont icon-js" style=""></span>JavaScript<!----></a></li><li><a class="route-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/%E9%9D%A2%E8%AF%95/Vue.html" aria-label="Vue"><span class="font-icon icon iconfont icon-vue" style=""></span>Vue<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E9%9D%A2%E8%AF%95/React.html" aria-label="React"><span class="font-icon icon iconfont icon-react" style=""></span>React<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E9%9D%A2%E8%AF%95/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" aria-label="性能优化"><span class="font-icon icon iconfont icon-OA_xingnengyouhua" style=""></span>性能优化<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8.html" aria-label="浏览器"><span class="font-icon icon iconfont icon-w_liulanqi" style=""></span>浏览器<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html" aria-label="计算机网络"><span class="font-icon icon iconfont icon-wangluo" style=""></span>计算机网络<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E9%9D%A2%E8%AF%95/%E5%A4%A7%E5%8E%82%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9.html" aria-label="大厂高频考点"><span class="font-icon icon iconfont icon-dachang" style=""></span>大厂高频考点<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E9%9D%A2%E8%AF%95/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81.html" aria-label="手撕代码"><span class="font-icon icon iconfont icon-code" style=""></span>手撕代码<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.html" aria-label="前端工程化"><span class="font-icon icon iconfont icon-xiangmuguanli" style=""></span>前端工程化<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95.html" aria-label="面试记录"><span class="font-icon icon iconfont icon-interview" style=""></span>面试记录<!----></a></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><span class="font-icon icon iconfont icon-vue" style=""></span>Vue</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/GodX-18" target="_blank" rel="noopener noreferrer">GodX</a></span><span property="author" content="GodX"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-05-22T00:00:00.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 18 分钟</span><meta property="timeRequired" content="PT18M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category2 clickable" role="navigation">面试</span><!--]--><meta property="articleSection" content="面试"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item tag2 clickable" role="navigation">Vue</span><!--]--><meta property="keywords" content="Vue"></span></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!--[--><!----><!--]--><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/#vue-的设计模式">Vue 的设计模式</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#介绍一下-mvvm-模式和-mvc-模式有什么区别">介绍一下 MVVM 模式和 MVC 模式有什么区别？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/#生命周期">生命周期</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#vue2-的生命周期有哪些">Vue2 的生命周期有哪些</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#keep-alive-中的生命周期有哪些">keep-alive 中的生命周期有哪些</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#父子组件生命周期执行顺序">父子组件生命周期执行顺序</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#平时发送异步请求在哪个生命周期-并解释原因">平时发送异步请求在哪个生命周期，并解释原因</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#created-和-mouted-区别">created 和 mouted 区别</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/#数据绑定">数据绑定</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#组件中的-data-为什么是一个函数">组件中的 data 为什么是一个函数？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#vue-的双向数据绑定是如何实现的">Vue 的双向数据绑定是如何实现的</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#为什么-vue3-用-proxy-代替了-vue2-中的-object-defineproperty">为什么 Vue3 用 proxy 代替了 Vue2 中的 Object.defineProperty</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#this-set-的用处及用法">this.$set() 的用处及用法</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#vue-中的数据为什么频繁变化时只会更新一次">Vue 中的数据为什么频繁变化时只会更新一次</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#this-nexttick-作用及实现原理">this.$nextTick() 作用及实现原理</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/#组件通信">组件通信</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#父子组件通信">父子组件通信</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#子组件可以直接改变父组件的值吗">子组件可以直接改变父组件的值吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#平行组件通信">平行组件通信</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#什么是状态管理-为什么需要状态管理">什么是状态管理？为什么需要状态管理？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#mutations-能不能做异步">mutations 能不能做异步</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#怎么解决刷新页面时-vuex-中数据丢失的问题">怎么解决刷新页面时，Vuex 中数据丢失的问题？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#vuex-和-localstorage-的区别">Vuex 和 localStorage 的区别</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/#虚拟-dom-和-diff-算法">虚拟 dom 和 diff 算法</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#什么是虚拟-dom-有什么用">什么是虚拟 dom ？有什么用？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#虚拟-dom-的解析过程">虚拟 dom 的解析过程</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#diff-算法">diff 算法</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#vue-中-key-的作用">Vue 中 key 的作用</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#vue2-和-vue3中diff算法的区别">Vue2 和 Vue3中diff算法的区别</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/#vue2-和-vue3的区别">Vue2 和 Vue3的区别</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#生命周期-1">生命周期</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#diff-算法-1">diff 算法</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#数据响应式原理">数据响应式原理</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#组件通信-1">组件通信</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/#标签和属性">标签和属性</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#v-if-和-v-show-的区别">v-if 和 v-show 的区别</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#v-if-和-v-for-哪个优先级更高">v-if 和 v-for 哪个优先级更高</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#slot-插槽-的作用">slot（插槽）的作用</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#computed-计算属性-和-watch-监听属性-的区别">computed（计算属性）和 watch（监听属性）的区别</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/#路由">路由</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#vue-实现路由跳转的方法">Vue 实现路由跳转的方法</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#路由的-hash-模式和-history-模式的区别">路由的 hash 模式和 history 模式的区别</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/#原理">原理</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#vue-如何实现响应式">vue 如何实现响应式</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#nexttick">$nextTick</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#computed">Computed</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#watch">watch</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="/#开放性问题">开放性问题</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#说说-vue-的优缺点">说说 Vue 的优缺点</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#vue-模板编译原理">Vue 模板编译原理</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="/#说一说-vue-的性能优化">说一说 Vue 的性能优化</a></li><!----><!--]--></ul></li><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h2 id="vue-的设计模式" tabindex="-1"><a class="header-anchor" href="#vue-的设计模式"><span>Vue 的设计模式</span></a></h2><h3 id="介绍一下-mvvm-模式和-mvc-模式有什么区别" tabindex="-1"><a class="header-anchor" href="#介绍一下-mvvm-模式和-mvc-模式有什么区别"><span>介绍一下 MVVM 模式和 MVC 模式有什么区别？</span></a></h3><p>MVVM 模式是一种软件架构设计模式，它将应用程序分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。模型负责处理数据和业务逻辑，视图负责显示用户界面，视图模型负责连接视图和模型，并实现数据绑定和命令模式。MVVM 模式的目的是实现视图和模型的解耦，使代码更易于维护和测试。</p><p>MVC 模式也是一种软件架构设计模式，它将应用程序分为三个部分：模型（Model）、视图（View）和控制器（Controller）。模型负责处理数据和业务逻辑，视图负责显示用户界面，控制器负责接收用户输入并调用模型或视图进行响应。MVC 模式的目的是实现关注点的分离，使代码更具有可扩展性和可复用性。</p><p>MVVM 模式和 MVC 模式的主要区别有：</p><ul><li>MVVM 模式中，视图和模型之间没有直接的联系，而是通过视图模型进行交互。视图模型可以监听模型的变化，并自动更新视图。视图也可以通过命令或事件通知视图模型进行操作。这样实现了双向数据绑定，使得视图和模型保持同步。</li><li>MVC 模式中，视图和模型之间可以有直接的联系，也可以通过控制器进行中介。控制器负责将用户输入转换为对模型或视图的操作。控制器也可以根据模型的变化更新视图。这样实现了单向数据流，使得控制器成为应用程序的核心。</li></ul><p>MVVM 模式适合于需要处理复杂的用户界面和业务逻辑的应用程序，例如桌面应用程序或移动应用程序。MVVM 模式可以利用数据绑定框架或库来简化开发过程，例如 Vue.js, React.js, Angular.js 等。</p><p>MVC 模式适合于需要快速开发和部署的应用程序，例如 Web 应用程序或服务端应用程序。MVC 模式可以利用 Web 开发框架或工具来提高开发效率，例如 Spring MVC, <a href="http://ASP.NET" target="_blank" rel="noopener noreferrer">ASP.NET<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> MVC, Zend Framework, JSF 等。</p><h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期"><span>生命周期</span></a></h2><h3 id="vue2-的生命周期有哪些" tabindex="-1"><a class="header-anchor" href="#vue2-的生命周期有哪些"><span>Vue2 的生命周期有哪些</span></a></h3><figure><img src="https://cn.vuejs.org/assets/lifecycle_zh-CN.FtDDVyNA.png" alt="组件生命周期图示" tabindex="0" loading="lazy"><figcaption>组件生命周期图示</figcaption></figure><p>Vue 2 的生命周期包含了一系列钩子函数，它们在 Vue 组件实例的不同阶段被调用，允许开发者在特定时刻运行自己的代码。让我简单介绍一下这些生命周期阶段：</p><ol><li><strong>创建阶段</strong>： <ul><li><code>beforeCreate</code>: 在实例初始化之后、数据观测和事件配置之前调用。</li><li><code>created</code>: 在实例创建完成后被调用，此时实例已完成数据观测，但尚未挂载到 DOM 上。</li></ul></li><li><strong>挂载阶段</strong>： <ul><li><code>beforeMount</code>: 在挂载开始之前被调用，此时模板编译已完成，但尚未将组件挂载到 DOM。</li><li><code>mounted</code>: 在实例挂载到 DOM 后被调用，此时组件已经渲染到页面上。</li></ul></li><li><strong>更新阶段</strong>： <ul><li><code>beforeUpdate</code>: 在数据更新之前、DOM 重新渲染之前被调用。</li><li><code>updated</code>: 在数据更新后、DOM 重新渲染之后被调用。</li></ul></li><li><strong>销毁阶段</strong>： <ul><li><code>beforeDestroy</code>: 在实例销毁之前被调用，此时实例仍然完全可用。</li><li><code>destroyed</code>: 在实例销毁后被调用，此时实例已经被销毁，不再可用。</li></ul></li></ol><p>这些生命周期钩子允许你在不同的阶段执行自定义逻辑，比如初始化数据、访问 DOM 元素、清理资源等。详细了解每个钩子的用法可以参考 <a href="https://cn.vuejs.org/guide/essentials/lifecycle.html" target="_blank" rel="noopener noreferrer">Vue.js 官方文档<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="keep-alive-中的生命周期有哪些" tabindex="-1"><a class="header-anchor" href="#keep-alive-中的生命周期有哪些"><span>keep-alive 中的生命周期有哪些</span></a></h3><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">activated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在首次挂载、</span>
    <span class="token comment">// 以及每次从缓存中被重新插入的时候调用</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">deactivated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在从 DOM 上移除、进入缓存</span>
    <span class="token comment">// 以及组件卸载时调用</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li><code>activated</code> 在组件挂载时也会调用，并且 <code>deactivated</code> 在组件卸载时也会调用。</li><li>这两个钩子不仅适用于 <code>&lt;KeepAlive&gt;</code> 缓存的根组件，也适用于缓存树中的后代组件。</li></ul></div><h3 id="父子组件生命周期执行顺序" tabindex="-1"><a class="header-anchor" href="#父子组件生命周期执行顺序"><span>父子组件生命周期执行顺序</span></a></h3><ul><li>加载过程：父组件beforeCreate =&gt; 父组件created =&gt; 父组件beforeMount =&gt; 子组件beforeCreate =&gt; 子组件created =&gt; 子组件 beforeMount =&gt; 子组件mounted =&gt; 父组件mounted</li><li>更新过程：父组件beforeUpdate =&gt; 子组件beforeUpdate =&gt; 子组件updated =&gt; 父组件updated</li><li>销毁过程：父组件beforeDestroy =&gt; 子组件 beforeDestroy =&gt; 子组件 destoryed =&gt; 父组件 destoryed</li></ul><h3 id="平时发送异步请求在哪个生命周期-并解释原因" tabindex="-1"><a class="header-anchor" href="#平时发送异步请求在哪个生命周期-并解释原因"><span>平时发送异步请求在哪个生命周期，并解释原因</span></a></h3><ul><li>平时发送异步请求，我一般会在 created 生命周期中调用，因为这样可以更快地获取到服务端的数据，减少页面的 loading 时间，提高用户体验。</li><li>另外，如果我需要进行服务端渲染（SSR），那么在 created 中调用异步请求也有助于保持数据的一致性，因为 SSR 不支持 beforeMount 和 mounted 生命周期。</li><li>当然，如果我需要在异步请求之后进行一些 DOM 操作，那么我也可以在 mounted 生命周期中调用异步请求，但这样可能会导致页面的二次渲染。</li></ul><div class="hint-container tip"><p class="hint-container-title">为什么SSR 不支持 beforeMount 和 mounted 生命周期？</p><p>在服务端渲染（SSR）中，<code>beforeMount</code> 和 <code>mounted</code> 生命周期钩子不被支持的原因是，SSR 主要负责将 Vue 组件渲染成 HTML 字符串，这个过程发生在服务器上，而不是在客户端浏览器中。由于 SSR 只生成 HTML 字符串，它不会创建或操作 DOM，因此没有必要使用与 DOM 相关的生命周期钩子。</p><p>具体来说：</p><ul><li><code>beforeMount</code> 钩子在组件挂载到 DOM 之前被调用，但在 SSR 中，没有 DOM 操作，所以这个钩子不会被执行。</li><li><code>mounted</code> 钩子在组件挂载完成后被调用，通常用于那些需要访问或操作 DOM 的任务。由于 SSR 不涉及 DOM 操作，这个钩子同样不会被执行。</li></ul><p>在 SSR 中，只有 <code>beforeCreate</code> 和 <code>created</code> 这两个生命周期钩子会被调用，因为这些阶段发生在实例初始化过程中，而不涉及 DOM。</p><p>如果你需要在客户端执行与 DOM 相关的操作，可以在 <code>mounted</code> 钩子中进行，这样当应用在客户端激活（hydrate）时，这些操作就会被执行。这也是为什么推荐在 <code>created</code> 钩子中进行数据获取等操作，因为这有助于保持客户端和服务器端代码的一致性。</p></div><h3 id="created-和-mouted-区别" tabindex="-1"><a class="header-anchor" href="#created-和-mouted-区别"><span>created 和 mouted 区别</span></a></h3><p>created 和 mounted 是 Vue.js 中的两个生命周期钩子函数，它们分别用于在 Vue 实例被创建之后和挂载到 DOM 之后执行一些逻辑。具体区别和应用场景如下：</p><ul><li><p>created：</p><ul><li>在 Vue 实例被创建之后立即执行。</li><li>在这个阶段，Vue 实例的数据观测和事件配置已完成，但尚未挂载到 DOM 上。</li><li>通常在这个阶段执行一些数据初始化、事件监听、异步请求等逻辑，但不涉及 DOM 操作。例如，你可以在 created 中发送一个 Ajax 请求来获取数据，并将其赋值给 data 中的属性。</li></ul></li><li><p>mounted：</p><ul><li>在 Vue 实例挂载到 DOM 之后执行。</li><li>在这个阶段，Vue 实例已经完成了数据观测、编译渲染、创建虚拟 DOM 和真实 DOM 等所有过程，可以进行 DOM 操作。</li><li>通常在这个阶段执行一些需要依赖 DOM 元素的逻辑，如获取元素尺寸、绑定事件、设置定时器等。例如，你可以在 mounted 中使用 echarts 来绘制一个图表，并将其插入到某个元素中。</li></ul></li></ul><h2 id="数据绑定" tabindex="-1"><a class="header-anchor" href="#数据绑定"><span>数据绑定</span></a></h2><h3 id="组件中的-data-为什么是一个函数" tabindex="-1"><a class="header-anchor" href="#组件中的-data-为什么是一个函数"><span>组件中的 data 为什么是一个函数？</span></a></h3><p>是为了确保每个组件实例都拥有其自己的数据副本，而不是共享相同的数据。通过将 data 属性设置为函数，每次组件被实例化时，都会调用该函数返回一个新的数据对象，从而避免数据共享和潜在的副作用。</p><h3 id="vue-的双向数据绑定是如何实现的" tabindex="-1"><a class="header-anchor" href="#vue-的双向数据绑定是如何实现的"><span>Vue 的双向数据绑定是如何实现的</span></a></h3><p>Vue 的双向数据绑定是通过<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>来实现的。具体来说，Vue.js 使用了以下几个核心概念来实现双向绑定：</p><ol><li><p><strong>Observer</strong>: 这是一个数据监听器，利用 <code>Object.defineProperty()</code> 方法对属性进行劫持（监听），以便在属性值发生变化时能够得到通知并执行相应的操作。</p></li><li><p><strong>Dep</strong>: 一个消息订阅器，它的主要作用是收集订阅者，并在属性变化时执行订阅者的更新函数。</p></li><li><p><strong>Watcher</strong>: 订阅者，它会在初始化时将自己添加到 Dep 中。当数据变化时，Observer 会通知 Dep，进而触发 Watcher 绑定的更新函数，从而更新视图。</p></li><li><p><strong>Compile</strong>: 解析器，它会解析每个节点元素的相关指令（如 <code>v-model</code>），并初始化一个订阅者 Watcher，替换模板数据或绑定相应的函数。</p></li></ol><p>当数据发生变化时，Observer 会通知 Dep，Dep 会调用 Watcher 的 <code>update</code> 方法，进而更新视图。同时，当用户输入时（如在 <code>input</code> 元素中），视图的变化也会通过 <code>v-model</code> 指令更新数据模型，实现双向绑定。</p><p>这个过程中，Vue.js 的响应式系统会自动追踪依赖关系，确保数据和视图始终保持同步。在 Vue 3 中，这一机制得到了进一步的优化，使用了 Proxy 对象来实现数据的响应式，这比 <code>Object.defineProperty()</code> 方法提供了更好的性能和更多的可能性。</p><h3 id="为什么-vue3-用-proxy-代替了-vue2-中的-object-defineproperty" tabindex="-1"><a class="header-anchor" href="#为什么-vue3-用-proxy-代替了-vue2-中的-object-defineproperty"><span>为什么 Vue3 用 proxy 代替了 Vue2 中的 Object.defineProperty</span></a></h3><p>Vue3 使用 Proxy 替代 Vue2 中的 Object.defineProperty 主要有以下几个原因：</p><ol><li><strong>更全面的监控</strong>：Proxy 可以直接代理整个对象，可以监听对象某个属性值的变化，还可以监听对象属性的新增和删除。而 Object.defineProperty 只能给对象的某个已存在的属性添加对应的 getter 和 setter，所以它只能监听这个属性值的变化，而不能去监听对象属性的新增和删除。</li><li><strong>数组的处理</strong>：在 Vue2 中，由于 Object.defineProperty 只能劫持对象的属性访问，无法直接监测数组的变化，因此需要通过 hack 的方式实现数组的响应式。而 Proxy 在支持对象监测的同时，还支持数组的监听，不再需要额外的操作。</li><li><strong>性能优化</strong>：虽然实际上 Proxy 在性能上是要比 Object.defineProperty 差的，但是 Vue3 对响应式系统进行了重构和优化，采用了基于 Proxy 的 Observation 机制，使访问和修改响应式对象时的性能得到了优化。</li></ol><h3 id="this-set-的用处及用法" tabindex="-1"><a class="header-anchor" href="#this-set-的用处及用法"><span>this.$set() 的用处及用法</span></a></h3><p>在 Vue 中，<code>this.$set()</code> 是一个非常有用的方法，它的主要作用和用法如下：</p><ol><li><p><strong>用途</strong>：当 Vue 的 <code>data</code> 中声明的对象或数组，如果向对象中添加新的属性，更新此属性的值，视图是不会更新的⁵。这是因为 Vue 无法检测到对象属性的添加或删除⁵。在这种情况下，我们就需要使用 <code>this.$set()</code> 进行响应式的数据更新。</p></li><li><p><strong>用法</strong>：<code>this.$set(target, key, value)</code>。</p><ul><li><code>target</code>：要更改的数据源，可以是对象或者数组。</li><li><code>key</code>：要更改或者新增属性的具体数据（对象的 key 为键，数组的 key 为下标）。</li><li><code>value</code>：重新赋的值。</li></ul></li></ol><p>例如，如果你想在 <code>items</code> 数组的第一个位置添加一个新的对象 <code>{ message: &quot;更改one的值&quot;, id: &quot;0&quot; }</code>，你可以这样做：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">&quot;更改one的值&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">&quot;0&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样，<code>items</code> 数组的第一个元素就被成功地更新为新的对象，并且这个变化是响应式的，会触发视图的更新。</p><p>总的来说，<code>this.$set()</code> 是一个非常重要的方法，它能帮助我们解决 Vue 中的一些响应式问题。</p><h3 id="vue-中的数据为什么频繁变化时只会更新一次" tabindex="-1"><a class="header-anchor" href="#vue-中的数据为什么频繁变化时只会更新一次"><span>Vue 中的数据为什么频繁变化时只会更新一次</span></a></h3><p>因为 Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。</p><h3 id="this-nexttick-作用及实现原理" tabindex="-1"><a class="header-anchor" href="#this-nexttick-作用及实现原理"><span>this.$nextTick() 作用及实现原理</span></a></h3><p>Vue.js 在更新 DOM 时，会异步执行更新操作。它内部维护了一个队列，当数据变化时，Vue.js 将组件实例添加到队列中。如果这个实例已经在队列中，那么就跳过，避免重复添加。然后，在下一个事件循环 “tick” 中，Vue.js 刷新队列并执行实际（已去重的）工作。</p><p><code>this.$nextTick()</code> 方法实际上是对这个过程的封装。当你在数据变化之后，使用 <code>this.$nextTick()</code>，则回调函数将在 DOM 更新完成后被调用。</p><h2 id="组件通信" tabindex="-1"><a class="header-anchor" href="#组件通信"><span>组件通信</span></a></h2><h3 id="父子组件通信" tabindex="-1"><a class="header-anchor" href="#父子组件通信"><span>父子组件通信</span></a></h3><h3 id="子组件可以直接改变父组件的值吗" tabindex="-1"><a class="header-anchor" href="#子组件可以直接改变父组件的值吗"><span>子组件可以直接改变父组件的值吗？</span></a></h3><h3 id="平行组件通信" tabindex="-1"><a class="header-anchor" href="#平行组件通信"><span>平行组件通信</span></a></h3><h3 id="什么是状态管理-为什么需要状态管理" tabindex="-1"><a class="header-anchor" href="#什么是状态管理-为什么需要状态管理"><span>什么是状态管理？为什么需要状态管理？</span></a></h3><h3 id="mutations-能不能做异步" tabindex="-1"><a class="header-anchor" href="#mutations-能不能做异步"><span>mutations 能不能做异步</span></a></h3><h3 id="怎么解决刷新页面时-vuex-中数据丢失的问题" tabindex="-1"><a class="header-anchor" href="#怎么解决刷新页面时-vuex-中数据丢失的问题"><span>怎么解决刷新页面时，Vuex 中数据丢失的问题？</span></a></h3><h3 id="vuex-和-localstorage-的区别" tabindex="-1"><a class="header-anchor" href="#vuex-和-localstorage-的区别"><span>Vuex 和 localStorage 的区别</span></a></h3><h2 id="虚拟-dom-和-diff-算法" tabindex="-1"><a class="header-anchor" href="#虚拟-dom-和-diff-算法"><span>虚拟 dom 和 diff 算法</span></a></h2><h3 id="什么是虚拟-dom-有什么用" tabindex="-1"><a class="header-anchor" href="#什么是虚拟-dom-有什么用"><span>什么是虚拟 dom ？有什么用？</span></a></h3><h3 id="虚拟-dom-的解析过程" tabindex="-1"><a class="header-anchor" href="#虚拟-dom-的解析过程"><span>虚拟 dom 的解析过程</span></a></h3><h3 id="diff-算法" tabindex="-1"><a class="header-anchor" href="#diff-算法"><span>diff 算法</span></a></h3><h3 id="vue-中-key-的作用" tabindex="-1"><a class="header-anchor" href="#vue-中-key-的作用"><span>Vue 中 key 的作用</span></a></h3><h3 id="vue2-和-vue3中diff算法的区别" tabindex="-1"><a class="header-anchor" href="#vue2-和-vue3中diff算法的区别"><span>Vue2 和 Vue3中diff算法的区别</span></a></h3><p>Vue2和Vue3的diff算法有一些区别，主要有以下几点：</p><ul><li>Vue2使用双向指针来进行虚拟DOM的比较，而Vue3则使用了单向链表的方式。这样可以减少不必要的比较次数，提高性能。</li></ul><ul><li>在计算key值不同时，Vue2会采用首尾两端比较的方法，而Vue3则采用了更高效的“Map”数据结构。这样可以避免在乱序情况下进行暴力比对，减少移动节点的操作。</li><li>Vue3还对diff算法进行了一些优化，如静态提升、长列表优化、动态组件优化等，可以更好地处理特定的场景，提高应用的性能和响应速度。</li><li>Vue3还增强了异步更新控制，通过更细粒度的控制更新的优先级和批量更新，避免了不必要的更新操作，从而减少了diff算法的运行时间。</li></ul><h2 id="vue2-和-vue3的区别" tabindex="-1"><a class="header-anchor" href="#vue2-和-vue3的区别"><span>Vue2 和 Vue3的区别</span></a></h2><h3 id="生命周期-1" tabindex="-1"><a class="header-anchor" href="#生命周期-1"><span>生命周期</span></a></h3><h3 id="diff-算法-1" tabindex="-1"><a class="header-anchor" href="#diff-算法-1"><span>diff 算法</span></a></h3><h3 id="数据响应式原理" tabindex="-1"><a class="header-anchor" href="#数据响应式原理"><span>数据响应式原理</span></a></h3><h3 id="组件通信-1" tabindex="-1"><a class="header-anchor" href="#组件通信-1"><span>组件通信</span></a></h3><h2 id="标签和属性" tabindex="-1"><a class="header-anchor" href="#标签和属性"><span>标签和属性</span></a></h2><h3 id="v-if-和-v-show-的区别" tabindex="-1"><a class="header-anchor" href="#v-if-和-v-show-的区别"><span>v-if 和 v-show 的区别</span></a></h3><h3 id="v-if-和-v-for-哪个优先级更高" tabindex="-1"><a class="header-anchor" href="#v-if-和-v-for-哪个优先级更高"><span>v-if 和 v-for 哪个优先级更高</span></a></h3><h3 id="slot-插槽-的作用" tabindex="-1"><a class="header-anchor" href="#slot-插槽-的作用"><span>slot（插槽）的作用</span></a></h3><h3 id="computed-计算属性-和-watch-监听属性-的区别" tabindex="-1"><a class="header-anchor" href="#computed-计算属性-和-watch-监听属性-的区别"><span>computed（计算属性）和 watch（监听属性）的区别</span></a></h3><h2 id="路由" tabindex="-1"><a class="header-anchor" href="#路由"><span>路由</span></a></h2><h3 id="vue-实现路由跳转的方法" tabindex="-1"><a class="header-anchor" href="#vue-实现路由跳转的方法"><span>Vue 实现路由跳转的方法</span></a></h3><h3 id="路由的-hash-模式和-history-模式的区别" tabindex="-1"><a class="header-anchor" href="#路由的-hash-模式和-history-模式的区别"><span>路由的 hash 模式和 history 模式的区别</span></a></h3><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><h3 id="vue-如何实现响应式" tabindex="-1"><a class="header-anchor" href="#vue-如何实现响应式"><span>vue 如何实现响应式</span></a></h3><p>Vue是采用数据劫持结合发布者-订阅者模式的方式, Vue相应系统有三大核心：observe,dep,watcher;</p><ul><li>Observe：当一个Vue实例创建时，initData阶段，vue会遍历data选项的属性（observe），用 Object.defineProperty 将它们转为 getter/setter并且在内部追踪相关依赖(dep)，在属性被访问和修改时通知变化。</li><li>Compite：调用compile方法解析模版,当视图中有用到vue.data中数据的时候，会调用实例化watcher方法进行依赖收集</li><li>Watcher：是Observer和Compile之间通信的桥梁，当视图中遇到绑定的数据时,在watcher方法中会获取这个数据，此时会触发observe中的getter方法</li><li>Dep：发布订阅模式,observe中数据的getter被触发时会收集依watcher(dep.depend方法)</li><li>当有数据被改动时会触发observe中数据的setter，此时会调用dep.notify方法给所有订阅的watcher发通知（通过回掉方式）进行视图更新，此</li></ul><h3 id="nexttick" tabindex="-1"><a class="header-anchor" href="#nexttick"><span>$nextTick</span></a></h3><p>vue实现响应式并不是数据一更新就立刻触发dom变化，而是按照一定的策略对dom进行更新，<a href="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js#L42" target="_blank" rel="noopener noreferrer">源码位置<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，原理：</p><ul><li>首先会将所有的nextTick放到一个函数中，然后放在callbacks数组中，$nextTick没有传cb回调，则返回一个promise</li><li>接下来就是callbacks的执行时机 <ul><li>首先如果浏览器是否兼容promise，则用promise.resolve().then来执行callbacks</li><li>如果浏览器兼容MutationObserver,则用实例化的MutationObserver监听文本变化来执行回调</li><li>如果兼容setImmediate,则用setImmediate(cb)来执行回掉<br> 最后降级为用setTimeout(fn,0)来执行</li><li>在vue2.5.X版本中对于像v-on这样的DOM交互事件，默认走macroTimerFunc，也就是，跳过第一步promise的判断</li></ul></li></ul><h3 id="computed" tabindex="-1"><a class="header-anchor" href="#computed"><span>Computed</span></a></h3><ul><li>vue对象初始化的同时对计算属性进行初始化initComputed</li><li>computed会初始化Watcher实例，并在内实例化一个Dep消息订阅器用作后续收集依赖</li><li>当视图中有对computed引用的时候会第一次执行计算属性，调用watcher的evaluate方法，将dirty设置为false,并将结果保存在this.value中进行缓存</li><li>如果依赖没有更改，则下次获取computed会这直接返回this.value<br> 当computed所依赖的属性发生变化时会调用watcher的update方法将dirty设置为true，下次调用computed时就会重新计算</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Watcher</span><span class="token punctuation">{</span>
  ……
  <span class="token function">evaluate</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
  ……
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">initComputed</span><span class="token punctuation">{</span>
  …… 
  <span class="token comment">//计算属性的getter 获取计算属性的值时会调用</span>
	<span class="token function">createComputedGetter</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">computedGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  	<span class="token comment">//获取到相应的watcher</span>
	    <span class="token keyword">const</span> watcher <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_computedWatchers <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_computedWatchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    	 <span class="token comment">//watcher.dirty 参数决定了计算属性值是否需要重新计算，默认值为true，即第一次时会调用一次</span>
	      	<span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span>dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	      		<span class="token comment">/*每次执行之后watcher.dirty会设置为false，只要依赖的data值改变时才会触发
	      		watcher.dirty为true,从而获取值时从新计算*/</span>
	        	watcher<span class="token punctuation">.</span><span class="token function">evaluate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	      	<span class="token punctuation">}</span>
	      	<span class="token comment">//获取依赖</span>
	      	<span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	        	watcher<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	      	<span class="token punctuation">}</span>
	      	<span class="token comment">//返回计算属性的值</span>
	      	<span class="token keyword">return</span> watcher<span class="token punctuation">.</span>value
	    <span class="token punctuation">}</span>
	  <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
  ……
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="watch" tabindex="-1"><a class="header-anchor" href="#watch"><span>watch</span></a></h3><h2 id="开放性问题" tabindex="-1"><a class="header-anchor" href="#开放性问题"><span>开放性问题</span></a></h2><h3 id="说说-vue-的优缺点" tabindex="-1"><a class="header-anchor" href="#说说-vue-的优缺点"><span>说说 Vue 的优缺点</span></a></h3><h3 id="vue-模板编译原理" tabindex="-1"><a class="header-anchor" href="#vue-模板编译原理"><span>Vue 模板编译原理</span></a></h3><h3 id="说一说-vue-的性能优化" tabindex="-1"><a class="header-anchor" href="#说一说-vue-的性能优化"><span>说一说 Vue 的性能优化</span></a></h3><p>Vue 的性能优化是一个很重要的话题，它涉及到 Vue 应用的页面加载速度和更新速度两个方面。为了提高 Vue 的性能，我们可以从以下几个方面进行优化：</p><ul><li>代码优化：我们可以通过以下方法来减少代码量和提高代码质量： <ul><li>使用模块化和组件化的方式来组织代码，避免重复和冗余的代码，提高代码的复用性和可维护性。</li><li>使用 v-if 和 v-for 时注意避免不必要的渲染，给每个 v-for 的元素设置唯一的 key 值，提高 diff 算法的效率。</li><li>使用 computed 属性和 watch 选项来优化数据的计算和监听，避免在模板中使用复杂的表达式和过滤器。</li><li>使用事件代理的方式来处理多个元素的事件绑定，减少事件监听器的数量。</li><li>使用 keep-alive 组件来缓存不活动的组件，避免重复渲染。</li><li>使用异步组件和路由懒加载的方式来实现按需加载，减少首屏加载时间。</li><li>使用自定义指令和插件来封装常用的功能，提高代码的可读性和可扩展性。</li></ul></li><li>资源优化：我们可以通过以下方法来压缩和优化静态资源，如图片、字体、CSS 和 JS 文件： <ul><li>使用 Webpack 等打包工具来进行代码压缩、Tree-shaking、Scope Hoisting 等优化操作，减少打包后的文件体积。</li><li>使用 CDN 来存储和分发静态资源，提高资源的加载速度和可用性。</li><li>使用图片懒加载的方式来延迟加载图片，减少网络请求和内存占用。</li><li>使用 SVG 图标来替代图片图标，提高图标的清晰度和灵活性。</li><li>使用字体子集或 Web 字体加载器来优化字体文件的加载，减少字体文件的体积和阻塞时间。</li></ul></li><li>架构优化：我们可以根据应用的类型和需求来选择合适的架构方式，如 SSR、SSG、SPA 等，以提高应用的页面加载速度和用户体验： <ul><li>如果应用对 SEO 和首屏加载性能有较高的要求，可以使用 SSR（服务器端渲染）或 SSG（静态站点生成）的方式来直接返回包含内容的 HTML 代码，避免客户端渲染带来的额外开销。</li><li>如果应用对交互性和动态性有较高的要求，可以使用 SPA（单页应用）的方式来实现客户端渲染，提高应用的响应速度和灵活性。</li><li>如果应用既需要 SEO 和首屏加载性能，又需要交互性和动态性，可以使用 SSR + SPA 的混合模式，或者使用预渲染、骨架屏等技术来提升用户体验。</li></ul></li></ul></div><!--[--><!----><!--]--><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 1046529973@qq.com">GodX</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link nav-link prev" href="/%E9%9D%A2%E8%AF%95/JavaScript.html" aria-label="JavaScript"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><span class="font-icon icon iconfont icon-js" style=""></span>JavaScript</div></a><a class="route-link nav-link next" href="/%E9%9D%A2%E8%AF%95/React.html" aria-label="React"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">React<span class="font-icon icon iconfont icon-react" style=""></span></div></a></nav><div id="vp-comment" class="giscus-wrapper input-top" style="display:block;"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" preserveAspectRatio="xMidYMid" viewBox="0 0 100 100"><circle cx="28" cy="75" r="11" fill="currentColor"><animate attributeName="fill-opacity" begin="0s" dur="1s" keyTimes="0;0.2;1" repeatCount="indefinite" values="0;1;1"></animate></circle><path fill="none" stroke="#88baf0" stroke-width="10" d="M28 47a28 28 0 0 1 28 28"><animate attributeName="stroke-opacity" begin="0.1s" dur="1s" keyTimes="0;0.2;1" repeatCount="indefinite" values="0;1;1"></animate></path><path fill="none" stroke="#88baf0" stroke-width="10" d="M28 25a50 50 0 0 1 50 50"><animate attributeName="stroke-opacity" begin="0.2s" dur="1s" keyTimes="0;0.2;1" repeatCount="indefinite" values="0;1;1"></animate></path></svg></div><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><!----><div class="vp-copyright">Copyright © 2024 GodX </div></footer></div><!--]--><!--[--><!----><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-oXp7PBbS.js" defer></script>
  </body>
</html>
