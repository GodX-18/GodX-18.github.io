import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o,c as n,a as t}from"./app-oXp7PBbS.js";const c={},d=t(`<h2 id="数独" tabindex="-1"><a class="header-anchor" href="#数独"><span>数独</span></a></h2><p>在处理数独问题时，判断一个数字是否重复通常涉及以下三个检查：</p><ol><li><strong>行检查</strong>: 验证特定数字在当前行是否已出现。</li><li><strong>列检查</strong>: 验证特定数字在当前列是否已出现。</li><li><strong>宫检查</strong>: 验证特定数字在当前3x3的宫内是否已出现。</li></ol><p>具体实现时，你可以使用以下数据结构：</p><ul><li>三个 <code>9x9</code> 的二维数组 <code>rows</code>, <code>columns</code>, <code>boxes</code> 来分别存储行、列、宫的数字出现情况。每个数组的第一维代表行/列/宫的索引，第二维代表具体的数字（1-9），存储的值可以是布尔类型，表示该数字是否出现过。</li></ul><p>假定我们正在检查一个数字 <code>num</code> 是否可以放在数独的 <code>(row, col)</code> 位置上。以下是实施步骤:</p><ol><li><strong>行检查</strong>: 若 <code>rows[row][num]</code> 已被标记，表示 <code>num</code> 在当前行已存在。</li><li><strong>列检查</strong>: 若 <code>columns[col][num]</code> 已被标记，表示 <code>num</code> 在当前列已存在。</li><li><strong>宫检查</strong>: 大多数情况下，在 <code>9x9</code> 的数独中，宫的索引可以通过 <code>box_index = (row / 3) * 3 + col / 3</code> 来计算，其中 <code>/</code> 是整数除法。如果 <code>boxes[box_index][num]</code> 已被标记，表示 <code>num</code> 在当前宫内已存在。</li></ol><p>如果以上任何一项检查失败，表示数字 <code>num</code> 不能放在 <code>(row, col)</code> 的位置上。如果全部检查都通过，那么 <code>num</code> 可以放置在 <code>(row, col)</code> 上，并且应该更新 <code>rows</code>, <code>columns</code>, <code>boxes</code> 的信息来反映 <code>num</code> 的放置。</p><p>这里是一个简化的伪代码来说明如何进行这些检查:</p><div class="language-pseudo line-numbers-mode" data-ext="pseudo" data-title="pseudo"><pre class="language-pseudo"><code>初始化:
rows = 9x9 的二维数组，全部填充 false
columns = 9x9 的二维数组，全部填充 false
boxes = 9x9 的二维数组，全部填充 false

对于数独的每个格子 (row, col) 以及对应的数字 num:
    box_index = (row / 3) * 3 + col / 3
    if rows[row][num] 或 columns[col][num] 或 boxes[box_index][num]:
        return false // 发现重复

    // 放置数字，并更新追踪状态
    rows[row][num] = true
    columns[col][num] = true
    boxes[box_index][num] = true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，上述伪代码是假设你检查的是一个已经部分填充的数独，并且试图确认现有的填充是否满足数独的条件。如果你是在尝试解数独，你可能需要使用回溯（Backtracking）等算法。</p>`,11),i=[d];function l(r,s){return o(),n("div",null,i)}const u=e(c,[["render",l],["__file","概述.html.vue"]]),p=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95/%E7%9F%A9%E9%98%B5/%E6%A6%82%E8%BF%B0.html","title":"概述","lang":"zh-CN","frontmatter":{"title":"概述","date":"2024-01-17T00:00:00.000Z","order":1,"category":["算法"],"tag":["矩阵"],"description":"数独 在处理数独问题时，判断一个数字是否重复通常涉及以下三个检查： 行检查: 验证特定数字在当前行是否已出现。 列检查: 验证特定数字在当前列是否已出现。 宫检查: 验证特定数字在当前3x3的宫内是否已出现。 具体实现时，你可以使用以下数据结构： 三个 9x9 的二维数组 rows, columns, boxes 来分别存储行、列、宫的数字出现情况。每...","head":[["meta",{"property":"og:url","content":"https://godx-18.github.io/%E7%AE%97%E6%B3%95/%E7%9F%A9%E9%98%B5/%E6%A6%82%E8%BF%B0.html"}],["meta",{"property":"og:site_name","content":"烜"}],["meta",{"property":"og:title","content":"概述"}],["meta",{"property":"og:description","content":"数独 在处理数独问题时，判断一个数字是否重复通常涉及以下三个检查： 行检查: 验证特定数字在当前行是否已出现。 列检查: 验证特定数字在当前列是否已出现。 宫检查: 验证特定数字在当前3x3的宫内是否已出现。 具体实现时，你可以使用以下数据结构： 三个 9x9 的二维数组 rows, columns, boxes 来分别存储行、列、宫的数字出现情况。每..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-20T08:17:41.000Z"}],["meta",{"property":"article:author","content":"GodX"}],["meta",{"property":"article:tag","content":"矩阵"}],["meta",{"property":"article:published_time","content":"2024-01-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-01-20T08:17:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"概述\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-17T00:00:00.000Z\\",\\"dateModified\\":\\"2024-01-20T08:17:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"GodX\\",\\"url\\":\\"https://github.com/GodX-18\\"}]}"]]},"headers":[{"level":2,"title":"数独","slug":"数独","link":"#数独","children":[]}],"git":{"createdTime":1705738661000,"updatedTime":1705738661000,"contributors":[{"name":"GodX","email":"1046529973@qq.com","commits":1}]},"readingTime":{"minutes":2.02,"words":607},"filePathRelative":"算法/矩阵/概述.md","localizedDate":"2024年1月17日","excerpt":"<h2>数独</h2>\\n<p>在处理数独问题时，判断一个数字是否重复通常涉及以下三个检查：</p>\\n<ol>\\n<li><strong>行检查</strong>: 验证特定数字在当前行是否已出现。</li>\\n<li><strong>列检查</strong>: 验证特定数字在当前列是否已出现。</li>\\n<li><strong>宫检查</strong>: 验证特定数字在当前3x3的宫内是否已出现。</li>\\n</ol>\\n<p>具体实现时，你可以使用以下数据结构：</p>\\n<ul>\\n<li>三个 <code>9x9</code> 的二维数组 <code>rows</code>, <code>columns</code>, <code>boxes</code> 来分别存储行、列、宫的数字出现情况。每个数组的第一维代表行/列/宫的索引，第二维代表具体的数字（1-9），存储的值可以是布尔类型，表示该数字是否出现过。</li>\\n</ul>","autoDesc":true}');export{u as comp,p as data};
