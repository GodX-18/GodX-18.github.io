---
title: Node 核心模块
icon: nodeJS
order: 2
category:
  - 前端
tag:
  - nodejs	
---
## Path

* 内置模块，require 之后直接使用
* 用于处理文件 / 目录的路径

###  常用 API

* basename() 获取路径中基础名称
  ```js
  const path = require("path");
  /**
   *1 @return 返回值就是接收路径当中的最后一部分
   *2 第二个参数表示扩展名，如果扩展名匹配则去除，否则不做操作
   *3 处理目灵路径的时候如果说，结尾处有路径分割符，则也会放忽略掉
   */
  
  console.log("GodX------>log", path.basename(__filename)); // path.js
  console.log("GodX------>log", path.basename(__filename, ".js")); // path
  console.log("GodX------>log", path.basename(__filename, ".css")); // path.js
  console.log("GodX------>log", path.basename('/a/b/c')); // c
  console.log("GodX------>log", path.basename('/a/b/c/')); // c
  ```

* dirname() 获取路径中目录名称
  ```js
  const path = require("path");
  
  /**
   *1 @return 返回值就是接收路径当中的最后一部分的所在路径
   *2 处理目录路径的时候如果说，结尾处有路径分割符，则会被忽略掉
   */
  
  console.log("GodX------>log", path.dirname(__filename));
  console.log("GodX------>log", path.dirname("/a/b/c")); // /a/b
  console.log("GodX------>log", path.dirname("/a/b/c/")); // /a/b
  ```

* extname() 获取路径中扩展名称
  ```js
  const path = require("path");
  
  //*1 获取路径中的基础名称
  
  /**
   *1 @return 返回值就是接收路径当中相应文件的后缀名
   *2 处理目录路径中有多个点，则会匹配最后一个点后面的内容
   */
  
  console.log("GodX------>log", path.extname(__filename));
  console.log("GodX------>log", path.extname("/a/b/c")); // 空
  console.log("GodX------>log", path.extname("/a/b/c.js.css")); // .css
  console.log("GodX------>log", path.extname("/a/b/c.js.")); // .
  ```

* isAbsolute() 获取路径是否为绝对路径
  ```js
  const path = require("path");
  
  console.log("GodX------>log", path.isAbsolute("a")); // false
  console.log("GodX------>log", path.isAbsolute("/a")); // true
  console.log("GodX------>log", path.isAbsolute("///a")); // true
  console.log("GodX------>log", path.isAbsolute("")); // false
  console.log("GodX------>log", path.isAbsolute(".")); // false
  console.log("GodX------>log", path.isAbsolute("./a")); // false
  ```

* join()拼接多个路径片段
  ```js
  const path = require("path");
  
  console.log("GodX------>log", path.join("a/b", "..", "/c", "..", "index.html")); // a/index.html
  console.log("GodX------>log", path.join()); // .
  console.log("GodX------>log", path.join("")); // .
  console.log("GodX------>log", path.join("a/b", "/c", "", "index.html")); // a/b/c/index.html
  ```

* resolve() 返回绝对路径
  ```js
  const path = require("path");
  
  /**
   * 方法说明
   * @param {String} resolve([from],to)
   * from 默认是运行目录
   */
  
  console.log("GodX------>log", path.resolve());
  console.log("GodX------>log", path.resolve("..", "b", "index.html"));
  console.log("GodX------>log", path.resolve("a", "/b")); // /b
  console.log("GodX------>log", path.resolve("/a", "/b")); // /b
  console.log("GodX------>log", path.resolve("/a", "b")); // /a/b
  console.log("GodX------>log", path.resolve("index.html")); // 正常用法
  ```

* pasre() 解析路径
  ```js
  const path = require("path");
  
  /**
   *1 @return 接收一个路径，返回一个对象，包含不同的信息
   *2 root（根路径） dir（最后一个 / 的上一层路径） base（最后一个 / 后的文件名） ext（扩展名） name（文件名）
   */
  
  console.log("GodX------>log", path.parse("/a/b/c"));
  console.log("GodX------>log", path.parse("/a/b/c.js.css.html"));
  console.log("GodX------>log", path.parse("./a/b/c.js"));
  ```

* format() 序列化路径
  ```js
  const path = require("path");
  
  /**
   *1 @return 接收一个路径对象（path.parse返回），根据路径对象生成路径
   *2 root（根路径） dir（最后一个 / 的上一层路径） base（最后一个 / 后的文件名） ext（扩展名） name（文件名）
   */
  
  const obj = path.parse("/a/b/c");
  console.log("GodX------>log", path.format(obj)); // /a/b/c
  ```

* normalize() 规范化路径
  ```js
  const path = require("path");
  
  console.log('GodX------>log',path.normalize("")); // .
  console.log('GodX------>log',path.normalize("/a///b/c")); // /a/b/c
  console.log('GodX------>log',path.normalize("/a/b/../c")); // /a/c
  ```

## Buffer (缓冲区)

### 诞生背景

* JS 语言起初服务于浏览器平台，主要操作的数据类型是字符串
* Nodejs 的出现，使得 JS可以做一些 IO 操作，比如文件的读写、网络服务中数据的传输
* IO 行为操作的就是二进制数据
* Stream 流操作并非 Nodejs 独创
* 流操作配合管道实现数据分段传输
* 数据的端到端传输会有生产者和消费者
* 生产和消费的过程往往存在等待，产生等待时数据放在哪儿？

### 是什么？

* 无须 require 的一个全局变量

* Nodejs 中 Buffer 是一片独立的内存空间

### 在哪儿？

* 不占用 V8 的堆内存空间，但是由 V8 的 GC 来管理和回收

### 做什么？

* 实现 Nodejs 平台下的二进制数据操作
* 一般配合 Stream 流使用，充当数据缓冲区

![image-20230104111003358](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230104111003358.png)

### 创建Buffer

* alloc：创建指定字节大小的 buffer
* allocUnsafe：创建指定大小的 buffer(不安全），包含一些空间碎片
* from：接收数据，创建 buffer，默认使用 utf-8 编码
  * 只接收三种数据类型：字符串、数组、Buffer

```js
const b1 = Buffer.alloc(3);
const b2 = Buffer.allocUnsafe(3);

console.log("GodX------>log", b1); //  <Buffer 00 00 00>
console.log("GodX------>log", b2); // <Buffer 25 10 00> 带有其它数据

const b3 = Buffer.from("烜");
const b4 = Buffer.from([0xe7, 0x83, 0x9c]);

console.log("GodX------>log", b3); // <Buffer e7 83 9c>
console.log("GodX------>log", b4.toString()); // 将 Buffer 格式转换成 utf-8

const b5 = Buffer.from(b1);
const b6 = Buffer.from(b5); // 深拷贝，根据传入 Buffer 的长度和内容，开辟全新的内存

console.log("GodX------>log", b5); // <Buffer 00 00 00>
console.log("GodX------>log", b6); // <Buffer 00 00 00>

b5[0] = 17;

console.log("GodX------>log", b5); // <Buffer 11 00 00>
console.log("GodX------>log", b6); // <Buffer 00 00 00>
```

### Buffer 实例方法

* fill：使用数据填充 buffer，会重复填充，直到填满
  ```js
  let fillBuf = Buffer.alloc(6);
  let writeBuf = Buffer.alloc(6);
  
  /**
   * fill 方法说明
   * @description: fill(name,from,to)
   * @param {String} name 解码类型
   * @param {String} from 从第几个字节开始填充
   * @param {String} to 填充到第几个字节（不包含最后一个字节）
   */
  
  fillBuf.fill(Buffer.from("123"), 1, 4);
  
  console.log("GodX------>log", fillBuf); // <Buffer 00 31 32 33 00 00>
  console.log("GodX------>log", fillBuf.toString()); // GodX------>log 123
  ```

* write：向 buffer 中写入数据
  ```js
  /**
   * write 方法说明
   * @description: writ(name,from,to)
   * @param {String} name 解码类型
   * @param {String} from 从第几个字节开始写入
   * @param {String} to 写入到第几个字节（不包含最后一个字节）
   */
  
  writeBuf.write("123", 1, 4);
  
  console.log("GodX------>log", writeBuf); // GodX------>log <Buffer 00 31 32 33 00 00>
  console.log("GodX------>log", writeBuf.toString()); // 123
  ```

* toString: 从 buffer 中提取数据
  ```js
  /**
   * toString 方法说明
   * @description: toString(name,from,to)
   * @param {String} name 解码类型
   * @param {String} from 从第几个字节开始截取
   * @param {String} to 截取到第几个字节（不包含最后一个字节）
   */
  
  let a1 = Buffer.from("朱烜牛批"); // 一个中文三个字节
  console.log("GodX------>log", a1); // <Buffer e6 9c b1 e7 83 9c e7 89 9b e6 89 b9>
  console.log("GodX------>log", a1.toString("utf-8", 3, 9)); // 烜牛
  ```

* slice：截取 buffer
  ```js
  /**
   * slice 方法说明
   * @description: 同 slice
   */
  
  let a2 = Buffer.from("朱烜牛批"); // 一个中文三个字节
  let a3 = a2.slice(3);
  console.log("GodX------>log", a3); // <Buffer e7 83 9c e7 89 9b e6 89 b9>
  console.log("GodX------>log", a3.toString()); // 烜牛批
  ```

* indexOf：在 buffer 中查找数据
  ```js
  /**
   * indexOf 方法说明
   * @description: 同 indexOf
   * @return 匹配字节所在位置
   */
  
  let a4 = Buffer.from("zx朱烜牛批,烜love");
  console.log("GodX------>log", a4);
  console.log("GodX------>log", a4.indexOf("烜")); // 5
  console.log("GodX------>log", a4.indexOf("烜", 6)); // 15
  ```

* copy: 拷贝 buffer 中的数据
  ```js
  let b1 = Buffer.alloc(6);
  let b2 = Buffer.from("烜神");
  
  console.log("GodX------>log", b1); // <Buffer 00 00 00 00 00 00>
  
  /**
   * @description: 拷贝 Buffer
   * @param {String} 第一个： 拷贝存放的位置
   * @param {Number} 第二个： 拷贝到存放 Buffer 第几个字节
   * @param {Number} 第三个： 拷贝数据源的开始字节序列
   * @param {Number} 第四个： 拷贝数据源的结束字节序列
   * @createTime: 2023/01/08 10:20:49
   */
  
  b2.copy(b1, 3, 3, 6);
  
  console.log("GodX------>log", b1); // <Buffer 00 00 00 e7 a5 9e>
  console.log("GodX------>log", b1.toString()); // 神
  ```
  

### Buffer 的静态方法

* concat ：将多个 buffer 拼接成一个新的 buffer
  ```js
  const a1 = Buffer.from("单点");
  const a2 = Buffer.from("登录");
  
  let b1 = Buffer.concat([a1, a2]);
  let b2 = Buffer.concat([a1, a2], 9); // 第二个参数指定 buffer 的长度
  
  console.log("GodX------>log", b1.toString()); // 单点登录
  console.log("GodX------>log", b2.toString()); // 单点登
  ```

* isBuffer：判断当前数据是否为 buffer
  ```js
  console.log('GodX------>log',Buffer.isBuffer(b1)); // true
  ```

### 自定义 Buffer 之 split

* Buffer 的大小（长度）是固定的（在创建时确定），无法更改。

* 在原生Node的Buffer中**不能**直接使用split方法， 会报下面的错误,一定要自己去实现这个方法，且挂载到原型链上
  ```bash
  split is not a function
  ```

```js
Buffer.prototype.split = Buffer.prototype.split || function (seq) {
  // 存储最终切割的内容
  let arr = [];

  // 当前位置--
  let current = 0;

  // pos--在buffer中找到某个符合seq条件片段的索引位置
  let position = 0;

  while (this.indexOf(seq, current) !== -1) {
    // 在这个位置找到符合条件的内容
    position = this.indexOf(seq, current)

    // 将符合条件的前面一段buffer切出来
    let prevBuffer = this.slice(current, position)

    arr.push(prevBuffer);

    // 现在从新的位置开始继续找
    current = position + seq.length;
  }

  // 上面while结束，表示再也找不到符合seq的buffer了，现在需要将最后一段buffer装进数组
  arr.push(this.slice(current));

  return arr;
}

// 测试
let  buf  = Buffer.from('1,2,3,4,5');

let arr = buf.split(',')

console.log(arr)
console.log("第一段buffer，转成字符串--》",arr[0].toString())
console.log("第2段buffer，转成字符串--》",arr[1].toString())
console.log("第3段buffer，转成字符串--》",arr[2].toString())
```

## FS 模块

![image-20230209100508606](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230209100508606.png)

* FS 是内置核心模块，提供文件系统操作的 API
* 代码层面上 fs 分为基本操作类和常用 API

### 前置知识

* 权限位:用户对于文件所具备的操作权限
  ![image-20230209101754160](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230209101754160.png)
  ![](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230209102121481.png)
* 标识符（flag 操作符）
  * r：可读
  * w：可写
  * s：同步
  * +：执行相反操作
  * x：表示排它操作
  * a：表示追加操作
* 文件描述符
  * fd：就是操作系统分配给被打开文件的标识

### 文件操作API

* readFile:从指定文件中读取数据
  ```js
  fs.readFile(path.resolve(__dirname, "test.txt"), "utf-8", (err, data) => {
    console.log("GodX------>log", err);
    if (!err) {
      console.log(data);
    }
  });
  ```

* writeFile:向指定文件中写入数据

  * 如果路径不存在，将新建一个新的文件
  * r+ : 不会清空，直接从零开始写入（覆盖）
  * w+：先清空后写入

  ```js
  fs.writeFile(
    path.resolve(__dirname, "test.txt"),
    "888",
    {
      mode: 438,
      flag: "r+",
      encoding: "utf-8"
    },
    (err) => {
      if (!err) {
        fs.readFile(path.resolve(__dirname, "test.txt"), "utf-8", (err, data) => {
          console.log("GodX--", data);
        });
      }
    }
  );
  ```

* appendFile:追加的方式向指定文件中写入数据
  ```js
  fs.appendFile(
    path.resolve(__dirname, "test.txt"),
    "aaa",
    {
      flag: "r+"
    },
    (err) => {
      if (!err) {
        console.log("写入成功");
      }
    }
  );
  ```

* copyFile: 将某个文件中的数据拷贝至另一文件
  ```js
  //* copyFile
  fs.copyFile(path.resolve(__dirname, "test.txt"), path.resolve(__dirname, "path.txt"), () => {
    console.log("操作成功");
  });
  ```

* watchFile：对指定文件进行监控
  ```js
  fs.watchFile(path.resolve(__dirname, "test.txt"), { interval: 20 }, (curr, prev) => {
    if (curr.mtime !== prev.mtime) {
      console.log("文件被修改了");
      // 取消监控
      fs.unwatchFile(path.resolve(__dirname, "test.txt"));
    }
  });
  ```

### 文件操作实现 md 转 html

实现思路：

- 读取 md 和 css 内容
- 将上述读取出来的内容替换占位符，生成一个最终需要展的 Html 字符串
- 将上述的 Html 字符写入到指定的 Html 文件中
- 监听 md 文档内容的变经，然后更新 html 内容
- 使用 browser-sync 来实时显示 Html 内容

```js
const fs = require("fs");
const path = require("path");
const { marked } = require("marked");
const browserSync = require("browser-sync");

// 通过命令行参数传递 md地址
let mdPath = path.join(__dirname, process.argv[2]);
let cssPath = path.resolve("github.css"); // 初始化样式
let htmlPath = mdPath.replace(path.extname(mdPath), ".html");
console.log(mdPath, cssPath, htmlPath);

// 监听
fs.watchFile(mdPath, (cur, pre) => {
  if (cur.mtime !== pre.mtime) {
    fs.readFile(mdPath, "utf-8", (err, data) => {
      // 将 md-->html
      let htmlStr = marked(data);
      fs.readFile(cssPath, "utf-8", (err, data) => {
        let retHtml = temp.replace("{{content}}", htmlStr).replace("{{style}}", data);
        //   将上述内容写入到指定的html文件中，用于在浏览器中展示
        fs.writeFile(htmlPath, retHtml, (err) => {
          console.log("html create successful");
        });
      });
    });
  }
});

browserSync.init({
  browser: "",
  server: __dirname,
  watch: true,
  index: path.basename(htmlPath)
});

// html模板
const temp = ` 
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
            .markdown-body {
                box-sizing: border-box;
                min-width: 200px;
                max-width: 1000px;
                margin: 0 auto;
                padding: 45px;
            }
            @media (max-width: 750px) {
                .markdown-body {
                    padding: 15px;
                }
            }
            {{style}}
        </style>
    </head>
    <body>
        <div class="markdown-body">
            {{content}}
        </div>
    </body>
    </html>
`;

```

### 文件打开与关闭

* 边写边读的操作方式（流读取），适用于大文件的读取
* `fs.readFile()`，`fs.readFileSync()`和`fsPromises.readFile()`在返回数据前读取内存中文件的全部内容，不适用于大文件的读取

```js
fs.open(path.resolve(__dirname, "test.txt"), "r", (err, fd) => {
  console.log(fd); // 文件描述符
  fs.close(fd, (err) => {
    console.log("打开成功！");
  });
});
```

### 大文件读写操作

![image-20230214070746377](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230214070746377.png)

**fs.read**

* 相当于将磁盘中的数据读取出来放到缓冲区当中

```js
/**
 * @param rfd 定位当前被打开的文件
 * @param buf 用于表示当前缓中区
 * @param offset 表示当前从 buf 的哪个位置开始热行写入
 * @param length 表示当前次写入的长度
 * @param position 表示当前从文件的哪个位置开始读操作
 */

let buff = Buffer.alloc(10);
fs.open(path.resolve(__dirname, "test.txt"), "r", (err, rfd) => {
  fs.read(rfd, buff, 2, 4, 0, (err, readBytes, data) => {
    console.log(readBytes);
    console.log(data);
    console.log(data.toString());
  });
});
```

**fs.write**

* 将缓冲区中的内容写入到磁盘文件中

```js
let buff = Buffer.from("1234567890");
fs.open(path.resolve(__dirname, "b.txt"), "w", (err, wfd) => {
  fs.write(wfd, buff, 0, 4, 0, (err, written, buffer) => {
    console.log(written);
    fs.close(wfd);
  });
});
```

### 文件拷贝自定义实现（大文件）

* copyFile 是基于 readFile 和 writeFile写的，属于一次性读写操作，不适用于大体积文件的读写

**具体步骤**

1. 打开 a 文件，利用 read 将数据保存到 buffer 暂存起来
2. 打开 b 文件，利用 write 将 buffer 中数据写入到 b 文件中

```js
let buff = Buffer.alloc(10);
const BUFFER_SIZE = buff.length; // buffer 大小
let readOffset = 0;

fs.open(path.resolve(__dirname, "a.txt"), "r", (err, rfd) => {
  fs.open(path.resolve(__dirname, "b.txt"), "w", (err, wfd) => {
    function next() {
      fs.read(rfd, buff, 0, BUFFER_SIZE, readOffset, (err, readBytes) => {
        if (!readBytes) {
          // 如果条件成立，说明内容已经读取完毕
          fs.close(rfd, () => {});
          fs.close(wfd, () => {});
          console.log("GodX------>log", "拷贝完成");
          return;
        }
        readOffset += readBytes;
        fs.write(wfd, buff, 0, readBytes, (err, written) => {
          console.log("GodX------>log", written);
          next();
        });
      });
    }
    next();
  });
});
```

### 目录操作 API

* access: 判断文件或目录是否具有操作权限
  ```js
  fs.access(path.resolve(__dirname, "a.txt"), (err) => {
    if (err) {
      console.log("GodX------>log", err);
    } else {
      console.log("有操作权限");
    }
  });
  ```

* stat:获取目录及文件信息
  ```js
  fs.stat(path.resolve(__dirname, "a.txt"), (err, statObj) => {
    const { size, isFile } = statObj;
    console.log("GodX------>log", size);
    console.log("GodX------>log", statObj.isFile()); 
    console.log("GodX------>log", statObj.isDirectory());
  });
  ```

* mkdir：创建目录

  ```js
  // recursive：为 true 时，递归创建目录
  fs.mkdir(path.resolve(__dirname, "yy"), { recursive: false }, (err) => {
    if (!err) {
      console.log("GodX------>log创建成功");
    } else {
      console.log("GodX------>log", err);
    }
  });
  ```

* rmdir:删除目录

  * 默认情况下，只能删除非空的目录
  * recursive 为 true 时，递归删除目录下的所有内容

  ```js
  fs.rmdir(path.resolve(__dirname, "aa"), { recursive: true }, (err) => {
    if (err) {
      console.log("删除失败", err);
    } else {
      console.log("删除成功");
    }
  });
  ```

* readdir：读取目录中内容
  ```js
  fs.readdir(path.resolve(__dirname, "markdownToHtml"), (err, files) => {
    if (!err) {
      console.log(files);
    } else {
      console.log("读取失败");
    }
  });
  ```

  ![image-20230217150638035](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230217150638035.png)

  ![image-20230217150655760](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230217150655760.png)

* unlink: 删除指定文件
  ```js
  fs.unlink(path.resolve(__dirname, "b.txt"), (err) => {
    if (!err) {
      console.log("删除成功");
    }
  });
  ```

### 创建目录之同步实现

```js
function makeDirSync(dirPath) {
  // path.sep：windows 环境下为 ‘\\’，linux 下为 ‘/’
  let items = dirPath.split(path.sep);
  for (let i = 1; i <= items.length; i++) {
    let dir = items.slice(0, i).join(path.sep);
    try {
      fs.accessSync(dir);
    } catch (err) {
      fs.mkdirSync(dir);
    }
  }
}

makeDirSync("a/b/c");
```

### 创建目录之异步实现

```js
function mkDir(dirPath, cb) {
  let parts = dirPath.split(path.sep);
  let index = 1;

  function next() {
    // 创建完毕
    if (index > parts.length) return cb && cb();
    // 当前创建的目录
    let current = parts.slice(0, index++).join("/");
    // 判断有无权限创建（如果报错则说明目录不存在）
    fs.access(current, (err) => { 
      if (err) {
        fs.mkdir(current, () => {
          console.log("GodX------>log", "文件不存在，创建当前目录");
          next();
        });
      } else {
        console.log("GodX------>log", "文件已存在，创建下一级目录");
        next();
      }
    });
  }
  next();
}
```

***将 access 和 mkdir 处理成 async/await 风格***

```js
const access = promisify(fs.access);
const mkdir = promisify(fs.mkdir);

async function myMkdir(dirPath, cb) {
  let parts = dirPath.split("/");
  for (let index = 1; index <= parts.length; index++) {
    let current = parts.slice(0, index).join("/");
    try {
      await access(current);
    } catch (err) {
      await mkdir(current);
    }
  }
  cb && cb();
}
```

### 递归删除目录（模拟 mkdir）

```js
function myRmdir(dirPath, cb) {
  fs.stat(dirPath, (err, statObj) => {
    if (statObj.isDirectory()) {
      // 目录 -----> 继续读取
      fs.readdir(dirPath, (err, files) => {
        const dirs = files.map((item) => path.join(dirPath, item));
        let index = 0;
        function next() {
          if (index == dirs.length) return fs.rmdir(dirPath, cb);
          let current = dirs[index++];
          myRmdir(current, next);
        }
        next()
      });
    } else {
      // 文件 ---> 直接删除
      fs.unlink(dirPath, cb);
    }
  });
}

myRmdir(path.resolve(__dirname, "yyy"), () => {
  console.log("GodX------>log", "删除成功！");
});
```

## 模块化

### 前端开发为什么需要模块化？

**传统开发常见问题**

* 命名冲突和污染
* 代码冗余，无效请求多
* 文件间的依赖关系复杂

以上问题导致项目难以维护不方便复用

### 什么是模块？

- 将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来
- 每个模块的内部数据和方法是私有的，只是向外部暴露一些属性和方法（接口）供其它模块使用

### 常见的模块化规范

* commonjs
* AMD
* CMD
* ES modules

### 模块化总结

* 模块化是前端走向工程化中的重要一环
* 早期 JS 语言层面没有模块化规范
* Commonjs、AMD、CMD 都是模块化规范
* ES6 中将模块化纳入标准规范
* 当下常用规范是 Commonjs（服务端）与 ESM

### CommonJS

* Common JS 规范起初是为了弥补 JS语言模块化缺陷
* Common JS是语言层面的规范，当前主要用于 Node.js
* CommonJS 规定模块化分为引入、定义、标识符三个部分
* Moudle 在任意模块中可直接使用包含模块信息
* Require 接收标识符，加载目标模块
* Exports 与 module.exports 都能导出模块数据
* CommonJS规范定义模块的加载是同步完成

**模块引用**

* 使用 require 导入其它模块

**模块定义**

* 任意一个文件就是一个模块，具有独立作用域

**模块标识**

* 将模块 ID 传入 require 实现目标模块定位

**module 属性**

* 任意 is 文件就是一个模块，可以直接使用 module 属性
* id：返回模块标识符，一般是一个绝对路径
* filename: 返回文件模块的绝对路径
* loaded: 返回布尔值，表示模块是否完成加载
* parent: 返回对象存放调用当前模块的模块
* children: 返回数组，存放当前模块调用的其它模块
* exports：返回当前模块需要暴露的内容
* paths：返回数组，存放不同目录下的 node_modules 位置

**module.exports 与 exports 有何区别？**

* `exports` 对象是 `module` 对象的一个属性,在初始时 `module.exports` 和 `exports` 指向同一块内存区域
* 模块导出的是 `module.exports` , `exports` 只是对它的引用,在不改变`exports` 内存的情况下,修改`exports` 的值可以改变 `module.exports` 的值
* 导出时尽量使用 `module.exports` ,以免因为各种赋值导致的混乱

**require 属性**

* 基本功能是读入并且执行一个模块文件
* resolve:返回模块文件绝对路径
* extensions:依据不同后缀名执行解析操作
* main:返回主模块对象

### Nodejs 与 CommonJs

* 使用 module.exports 与 require 实现模块导入与导出
  ```js
  // 导出
  const age = 10;
  const addFn = (a, b) => {
    return a + b;
  };
  
  module.exports = {
    age,
    addFn
  };
  // 导入
  const obj = require("./export");
  console.log("GodX------>log", obj.addFn(9,7));
  ```

* module属性及其常见信息获取
  ```js
  module.exports = 10;
  console.log("GodX------>log", module);
  ```

* exports 导出数据及其与 module.exports 区别
  ```js
  // 导出
  exports.age = 10;
  // 导入
  const obj = require("./export");
  
  console.log("GodX------>log", obj);
  // GodX------>log { age: 10 }
  ```

* CommonJS 规范下的模块同步加载

  ```js
  // 导出
  let iTime = new Date();
  while (new Date() - iTime < 4000) {}
  exports.age = 10;
  console.log("加载导入了");
  // 导入
  const obj = require("./export");
  console.log("导出的代码拿到了");
  ```
  
* 查看是否是主模块，用于代码调试
  ```js
  // 导出
  console.log(require.main === module); // false
  // 导入
  const obj = require("./export");
  console.log(require.main === module); // true
  ```

### 模块分类及加载流程

**模块分类**

* 内置模块：Node 源码编译时写入到二进制文件中
* 文件模块：代码运行时，动态加载，相对于内置模块较慢

**加载流程**

* 路径分析：依据标识符号确定模块位置
* 文件定位：确定目标中具体的文件及文件类型
* 编译执行：采用对应的方式完成文件的编译执行

**路径分析之标识符**

* 路径标识符
* 非路径标识符：比如 path、fs等核心模块

**文件定位的流程**

* 项目下存在 `m1.js`模块，导入时使用 `require('m1')`语法
* `m1.js` –> `m1.json` —> `m1.node`（补足扩展名依此去查找）
* 如果以上操作还没有找到，会当做一个包（目录）处理，去查找 `package.json`文件，使用 `JSON.parse()`解析，取出描述文件中的 main 属性值
* 如果 main 属性值没有扩展名，`main.js` –> `main.json` —> `main.node`（补足扩展名依此去查找）
* 以上操作还没有找到，默认会将 index 做为目标模块中的具体文件名称
* 最终还没有找到，就会报错

**编译执行**

* 使用 fs模块同步读入目标文件内容
* 对内容进行语法包装，生成可执行 JS 函数
* 调用函数时传入 exports、module、 require 等属性值

**JSON 文件编译执行**

* 将读取到的内容通过 JSON.parse() 进行解析

**缓存优化原则**

* 提高模块加载速度
* 当前模块不存在，则经历一次完整的加载流程
* 模块加载完成后，使用路径做为索引进行缓存

**加载流程小结**

* 路径分析：确定目标模块位置
* 文件定位：确定目标模块中的具体文件
* 编译执行：对模块内容进行编译，返回可用的 `exports` 对象

### 内置模块之 VM

创建独立运行的沙箱环境

**JS 中如何运行字符串代码**

* eval
* new Function
* vm

```js
const fs = require("fs");
const path = require("path");
const vm = require("vm");

const content = fs.readFileSync(path.resolve(__dirname, "./test.txt"), "utf-8");

//* eval
// eval(content);
// console.log('GodX------>log',a);

//* new Function
// let a = 1;
// let fn = new Function("a", "return a + 10");
// console.log("GodX------>log", fn(a));

//* vm
var a = 99;
vm.runInThisContext(a += 10); // runInThisContext创建的沙箱环境与外部隔离,但是可以访问到外部的全局变量
console.log("GodX------>log", a); // 109
```

### 第三方模块加载模拟实现

**核心逻辑**

* 路径分析
* 缓存优化
* 文件定位
* 编译执行

```js
const fs = require("fs");
const vm = require("vm");
const path = require("path");

function Module(id) {
  this.id = id;
  this.exports = {};
}
//? 路径分析
Module._resolveFilename = (filename) => {
  const absPath = path.resolve(__dirname, filename);
  if (fs.existsSync(absPath)) {
    return absPath;
  } else {
    let suffix = Object.keys(Module._extensions);
    for (let i = 0; i < suffix.length; i++) {
      let newPath = absPath + suffix[i];
      if (fs.existsSync(newPath)) {
        return newPath;
      }
    }
    throw new Error(`${filename} is not exist!`);
  }
};

//? 编译执行
Module.prototype.load = function () {
  const extname = path.extname(this.id);
  Module._extensions[extname](this);
};

Module._extensions = {
  ".js"(module) {
    //* 读取
    let content = fs.readFileSync(module.id, "utf-8");

    //* 包装
    content = Module.wrapper[0] + content + Module.wrapper[1];

    //* VM
    let compileFn = vm.runInThisContext(content);

    //* 准备参数的值
    let exports = module.exports;
    let dirname = path.dirname(module.id);
    let filename = module.id;

    //* 调用
    compileFn.call(exports, exports, myRequire, module, filename, dirname);
  },
  ".json"(module) {
    let content = JSON.parse(fs.readFileSync(module.id, "utf-8"));
    module.exports = content;
  }
};

Module.wrapper = ["(function (exports,require,module,__filename,__dirname) {", "})"];

Module._cache = {};

function myRequire(filename) {
  //*1 获取绝对路径
  const mPath = Module._resolveFilename(filename);

  //*2 缓存优先
  let cacheModule = Module._cache[mPath];
  if (cacheModule) return cacheModule.exports;

  //*3 创建空对象加载目标模块
  let module = new Module(mPath);

  //*4 缓存已经加载过的模块
  Module._cache[mPath] = module;

  //*5 执行加载（编译执行）
  module.load();

  //*6 返回数据
  return module.exports;
}

const obj = myRequire("./v");
console.log("GodX------>log", obj);
```

:::tip

对于 JavaScript 模块，加载器函数会首先读取模块的内容，然后在模块内容的前后添加一些包装代码，最后使用 `vm.runInThisContext` 方法在当前上下文中编译这个模块。

**为什么需要包装？**

在加载 JavaScript 模块时，需要为模块内容添加一些包装代码。这是为了确保模块的作用域（scope）正确，并防止模块内容与其他模块的内容发生命名冲突。

模块的代码包装是使用一个自执行函数来实现的，这个自执行函数有一个 `exports` 参数，用于存储模块的导出值。在执行自执行函数时，将当前模块的 `exports` 对象、`require` 函数、`module` 对象、`__filename` 和 `__dirname` 等参数作为参数传入这个函数。这样，模块中的所有变量和函数都会在这个自执行函数的作用域中定义，不会对其他模块或全局作用域造成影响。

因此，包装是确保模块的作用域正确、可维护、可扩展的重要手段。

:::

## Events 模块

通过 EventEmitter 类实现事件统一管理

### Events 与 EventEmitter

* node.js 是基于事件驱动的异步操作架构，内置 events 模块
* events 模块提供了 EventEmitter 类
* Node.js 中的很多内置核心模块继承 EventEmitter

### EventEmitter 常见 API

* on：添加当事件被触发时调用的回调函数
* emit：触发事件，按照注册的序同步调用每个事件监听器
* once：添加当事件在注册之后首次被触发时调用的回调函数
* off：移除特定的监听器

```js
const EventEmitter = require("events");

const ev = new EventEmitter();

// 注册事件
ev.once("test", () => {
  console.log("GodX------>log2");
});

ev.on("test", () => {
  console.log("GodX------>log");
});

// 订阅
ev.emit("test");

// 内置模块继承
const fs = require("fs");
const crt = fs.createReadStream();

crt.on('close')

```

### 发布订阅模式

定义对象间一对多的依赖关系

发布订阅可以解决什么问题？

![image-20230524135534469](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230524135534469.png)

**要素**

* 缓存队列，存放订阅者信息
* 具有增加、删除订阅的能力
* 状态改变时通知所有订阅着执行监听

**与观察者模式的区别**

* 发布订阅中存在调度中心
* 状态发生改变时，发布订阅无须主动通知

**代码实现**

:::code-tabs#shell

@tab EventEmitter

```js
class EventEmitter {
  constructor() {
    // { 'click': [fn1, fn2], 'change': [fn] }
    this.subs = Object.create(null);
  }

  // 注册事件
  $on(eventType, handler) {
    // 保证事件的类型是数组类型
    this.subs[eventType] = this.subs[eventType] || [];
    // 存储事件到事件中心
    this.subs[eventType].push(handler);
  }
  
    $off(event, callback) {
    if (this.events && this.events[event]) {
      this.events[event] = this.events[event].filter((item) => item !== callback);
    }
  }

  $once(eventName, listener) {
    const wrapper = (...args) => {
      listener.apply(this, args);
      this.$off(eventName, wrapper);
    };
    this.$on(eventName, wrapper);
  }

  // 触发事件
 $emit(event, ...args) {
    const eventList = this.events[event];
    if (eventList && eventList.length) {
      eventList.forEach((callback) => {
        callback(...args);
      });
    }
  }
}
```

@tab 使用

```js
let em = new EventEmitter();
em.$on("click", () => {
  console.log("click1");
});
em.$on("click", () => {
  console.log("click2");
});

em.$emit("click");
```

:::

## 浏览器中的 EventLoop

**完整事件环执行顺序**

1. 从上至下执行所有的同步代码
2. 执行过程中将遇到的宏任务与微任务添加至相应的队列
3. 同步代码执行完毕后，执行满足条件的微任务回调
4. 微任务队列执行完毕后执行所有满足需求的宏任务回调
5. 循环事件环操作

:::tip

每次执行完一个宏任务之后就会立刻检查微任务队列，清空微任务队列

:::

## Nodejs 下的事件循环

浏览器中有两个任务队列：

* 宏任务
* 微任务

而 Nodejs 中有 6 个：

![image-20230529153319630](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230529153319630.png)

* timers：执行 setTimout 与 setinterval 回调
* pending callbacks：执行系统操作的回调，例如 tcp udp
* idle, prepare：只在系统内部进行使用
* poll：执行与 I/O 相关的回调，比如文件的读取等
* check：执行 setlmmediate 中的回调
* close callbacks： 执行 close 事件的回调

**执行过程**

* 执行同步代码，将不同的任务添加至相应的队列
* 所有同步代码执行后会去执行满足条件微任务
* 所有微任务代码执行后会执行 timer 队列中满足的宏任务
* timer 中的所有宏任务执行完成后就会依次切换队列

:::tip 注意

* 在完成队列切换之前会先清空微任务代码

:::

![image-20230529160823912](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230529160823912.png)

Nodejs 中 nextTick 的优先级比 promise.then 要高

:::info

Node.js 从 v11.0.0 开始，为了与浏览器保持一致，每次执行完一个宏任务之后就会立刻检查微任务队列，清空微任务队列

在 Node.js 中，事件循环的顺序是：timers -> I/O callbacks -> idle, prepare -> poll -> check -> close callbacks -> process.nextTick

:::

**示例**

:::code-tabs#shell

@tab JS

```js
setTimeout(() => {
  console.log("s1");
  Promise.resolve().then(() => {
    console.log("p1");
  });
  process.nextTick(() => {
    console.log("t1");
  });
});
Promise.resolve().then(() => {
  console.log("p2");
});
console.log("start");

setTimeout(() => {
  console.log("s2");
  Promise.resolve().then(() => {
    console.log("p3");
  });
  process.nextTick(() => {
    console.log("t2");
  });
});

console.log("end");
```

@tab 结果

```js
// v11 以前
start、end、p2、s1、s2、t1、t2、p1、p3
// v11 以后
start、end、p2、s1、t1、p1、s2、t2、p3
```

:::

## Nodejs 与浏览器事件环的区别

* 任务队列数不同
  * 浏览器中只有两个任务队列
  * Nodejs 中有 6 个事件队列
* Nodejs 微任务执行时机不同
  * 二者都会在同步代码执行完毕后执行微任务
  * 浏览器平台下每当一个宏任务执行完毕后就清空微任务
  * Nodejs 平台在事件队列切换时回去清空微任务
* 微任务优先级不同
  * 浏览器事件环中，微任务存放于事件队列，先进先出
  * Nodejs 中 process.nextTick 先于 promise.then

## Nodejs 事件环常见问题

**setTimeout 和 setImmdiate 的执行顺序**

* 默认情况下，setTimeout 和 setImmdiate 的执行顺序是随机的。因为 setTimeout 的延时时间是不固定的

* 如果将 setTimeout 和 setImmdiate 放到回调当中，那么顺序将会是固定的，因为在 Node.js 中，事件循环的顺序是：timers -> I/O callbacks ->  poll，I / O 操作之后，会往下去执行 poll队列（setImmidate）,然后进入下一次事件环

## Stream

* Node.js 诞生之初就是为了提高 IO 性能，解决密集型 IO 事务（文件、网络等）
* 文件操作系统和网络模块实现了流接口
* Nodejs 中的流就是处理流式数据的抽象接口
* Node.js 中 stream 是流操作的抽象接口集合
* 可读、可写、双工、转换是单一抽象具体实现
* 流操作的核心功能就是处理数据
* Node.js 中处理数据模块继承了流和 EventEmitter

### 应用程序中为什么使用流来处理数据？

![image-20230613163514085](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230613163514085.png)

**常见问题**

* 同步读取资源文件，用户需要等待数据读取完成
* 资源文件最终一次性加载至内存，开销较大

![image-20230613163732948](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230613163732948.png)

![image-20230613163831814](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230613163831814.png)

**总结**

* 时间效率：流的分段处理可以同时操作多个数据 chunk
* 空间效率：同一时间流无需占据大内存空间
* 使用方便：流配合管道加工管理，扩展程序变得简单

### Nodejs 中流的分类

Nodejs 内置了 stream，它实现了流操作对象

* Readable: 可读流，能够实现数据的读取
* Writable: 可写流，能够实现数据的写操作
* Duplex：双工流，既可读又可写
* Tranform：转换流，可读可写，还能实现数据转换

### Nodejs 流特点

* Stream 模块实现了四个具体的抽象
* 所有的流都继承自 EventEmitter

### 初体验

```js
const fs = require("fs");
const path = require("path");

let rs = fs.createReadStream(path.resolve(__dirname, "./test.txt"));
let ws = fs.createWriteStream(path.resolve(__dirname, "./test1.txt"));
// 将 test.txt 文件拷贝至 test1.txt 文件下，没有则会创建
rs.pipe(ws);
```

### 可读流

生产供程序消费数据的流

**如何自定义可读流？**

* 继承 stream 里的 Readable
* 重写 _read 方法调用 push 产出数据

![image-20230613165751992](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230613165751992.png)

**消费数据**

* Readable 事件：当流中存在可读取数据时触发
* Data 事件：当流中数据块传给消费者后触发

![image-20230613170854692](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230613170854692.png)

**自定义可读流问题**

* 底层数据读取完成之后如何处理？
  * 返回 null 值表示完成
* 消费者如何获取可读流中的数据？
  * 提供两个事件来获取
    * readable
    * Data
* 消费数据为什么存在两种方式
  * 为了满足不同的数据使用场景
    * 读取一部分数据
    * 源源不断读取所有数据

**总结**

* 明确数据生产与消费流程
* 利用 API 实现自定义的可读流
* 明确数据消费的事件使用

### 可写流

用于消费数据的流

**基本使用**

![image-20230626165601088](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230626165601088.png)

### 双工流（Duplex）

即能生产又能消费的流叫做双工流

**自定义双工流**

* 继承 Duplex 类
* 重写 _read 方法，调用 push 生产数据
* 重写 _write 方法，调用 write 消费数据

![image-20230801094230718](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230801094230718.png)

### 转换流（Transform）

本质也是一个双工流，但是与双工流也有一些区别

* 双工流中读和写是相互独立的，读取的数据不能够被写操作直接使用
* 在转换流中，将读写操作进行联通，读取的数据够被写操作直接使用

**自定义转换流**

* 继承 Transform 类
* 重写 _transform 方法，调用 push 和 callback
* 重写 _flush 方法，处理剩余数据

![image-20230801095136571](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20230801095136571.png)

### 文件可读流

