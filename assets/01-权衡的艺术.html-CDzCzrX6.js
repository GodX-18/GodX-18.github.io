import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as s,a as t}from"./app-oXp7PBbS.js";const e={},p=t(`<h2 id="命令式和声明式-视图层框架" tabindex="-1"><a class="header-anchor" href="#命令式和声明式-视图层框架"><span>命令式和声明式（视图层框架）</span></a></h2><h3 id="命令式" tabindex="-1"><a class="header-anchor" href="#命令式"><span>命令式</span></a></h3><p><strong>有如下特点：</strong></p><ul><li>自然语言描述能够与代码产生一一对应的关系，更加关注过程</li><li>早期流行的<code>jquery</code>就是典型的命令式框架，如下：</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&#39;#app&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token string">&#39;hello world&#39;</span><span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&#39;ok&#39;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="声明式" tabindex="-1"><a class="header-anchor" href="#声明式"><span>声明式</span></a></h3><ul><li>不关注过程，更加关注结果</li><li>当下流行的 vue 框架就是声明式的：</li></ul><div class="language-vue line-numbers-mode" data-ext="vue" data-title="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>() =&gt; alert(&#39;ok&#39;)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  hello word
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="性能与可维护性的权衡" tabindex="-1"><a class="header-anchor" href="#性能与可维护性的权衡"><span>性能与可维护性的权衡</span></a></h2><p><strong>声明式代码的性能差于命令式代码的性能</strong></p><p>原因如下：</p><ul><li>声明式代码比命令式代码多出找出差异的性能消耗</li><li>声明式代码本身就是封装了命令式代码才实现了面向用户的声明式</li></ul><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>命令式代码可以做到极致的优化，因为我们明确知道哪些发生了变更，只做必要的修改就行了</p></div><p><strong>既然在性能层面命令式代码是更好的选择，那么为什么 Vue.js 要选择声明式的设计方案呢？</strong></p><ul><li>如果采用命令式代码开发，我们需要维护实现目标的整个过程，比较繁琐，而且可维护性较低</li><li>而声明式代码展示的就是我们要的结果，看上去更加直观</li></ul><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>在采用声明式提升可维护性的同时，性能就会有一定的损失，而框架设计者要做的就是：<strong>在保持可维护性的同时让性能损失最小化</strong></p></div><h2 id="虚拟-dom-的性能到底如何" tabindex="-1"><a class="header-anchor" href="#虚拟-dom-的性能到底如何"><span>虚拟 DOM 的性能到底如何</span></a></h2><h3 id="虚拟-dom-存在的意义" tabindex="-1"><a class="header-anchor" href="#虚拟-dom-存在的意义"><span>虚拟 DOM 存在的意义</span></a></h3><p><strong>最小化找出差异的性能消耗</strong></p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗</p></div><h3 id="比较-innerhtml-和虚拟-dom-的性能" tabindex="-1"><a class="header-anchor" href="#比较-innerhtml-和虚拟-dom-的性能"><span>比较 innerHtml 和虚拟 DOM 的性能</span></a></h3><table><thead><tr><th></th><th style="text-align:center;">innerHtml</th><th style="text-align:center;">虚拟DOM</th></tr></thead><tbody><tr><td>创建页面的性能</td><td style="text-align:center;">HTML 字符串拼接的计算量 + innerHtml 的 DOM 计算量</td><td style="text-align:center;">创建 JS 对象（VNode）的计算量 + 创建真实 DOM 的计算量</td></tr><tr><td>更新页面的性能</td><td style="text-align:center;">重新构建 HTML 字符串+销毁所有旧 DOM + 新建所有新DOM</td><td style="text-align:center;">创建新的 JS 对象（VNode）+ 必要的DOM 更新</td></tr><tr><td>性能因素</td><td style="text-align:center;">与数据变化量相关</td><td style="text-align:center;">与模版大小相关</td></tr></tbody></table><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>纯 JS 层面的操作要比 DOM 操作快得多，它们不在一个数量级上</p></div><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">innerHtml</th><th style="text-align:center;">虚拟DOM</th><th style="text-align:center;">原生 JS</th></tr></thead><tbody><tr><td style="text-align:center;">心智负担</td><td style="text-align:center;">中等</td><td style="text-align:center;">小</td><td style="text-align:center;">大</td></tr><tr><td style="text-align:center;">可维护性</td><td style="text-align:center;">差</td><td style="text-align:center;">强</td><td style="text-align:center;">差</td></tr><tr><td style="text-align:center;">性能</td><td style="text-align:center;">差</td><td style="text-align:center;">中上</td><td style="text-align:center;">高</td></tr></tbody></table><h2 id="运行时和编译时" tabindex="-1"><a class="header-anchor" href="#运行时和编译时"><span>运行时和编译时</span></a></h2><p>设计一个框架的时候，我们有三种选择：</p><ul><li>纯运行时</li><li>纯编译时</li><li>运行时 + 编译时</li></ul><p>首先我们来看三段代码：</p><p><strong>输入</strong></p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">children</span><span class="token operator">:</span><span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&#39;span&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">&#39;hello world&#39;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>编译函数</strong></p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Compiler</span><span class="token punctuation">(</span><span class="token parameter">html</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> 上面的输入
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>渲染函数</strong></p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Render</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span>root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">creatElment</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">.</span>children <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> text <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>children<span class="token punctuation">)</span>
    el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token operator">=&gt;</span> <span class="token function">Render</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span>el<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  root<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="纯运行时" tabindex="-1"><a class="header-anchor" href="#纯运行时"><span>纯运行时</span></a></h3><p><strong>特点</strong></p><ul><li><p>没有编译过程</p></li><li><p>用户的代码不用编译直接可以运行</p></li><li><p>比如用户直接手写树型结构的数据对象，然后作为渲染函数的的入参</p></li></ul><p><strong>缺点</strong></p><ul><li><p>没有编译的过程，因此我们没办法分析用户提供的内容</p></li><li><p>用户心智负担较大</p></li></ul><h3 id="纯编译时" tabindex="-1"><a class="header-anchor" href="#纯编译时"><span>纯编译时</span></a></h3><p><strong>特点</strong></p><ul><li><p>不支持任何运行时的内容，用户的代码通过编译器编译后才能运行，例如 Svelte 框架</p></li><li><p>将html编译和渲染都放到编译器中去做，用户心智负担小</p></li></ul><p><strong>缺点</strong></p><p>灵活性较差</p><h3 id="运行时-编译时" tabindex="-1"><a class="header-anchor" href="#运行时-编译时"><span>运行时 + 编译时</span></a></h3><ul><li><p>将用户的代码进行编译处理成能够直接运行的代码</p></li><li><p>比如 vue</p></li></ul>`,46),l=[p];function i(o,c){return a(),s("div",null,l)}const d=n(e,[["render",i],["__file","01-权衡的艺术.html.vue"]]),k=JSON.parse(`{"path":"/%E9%98%85%E8%AF%BB/Vuejs%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/01-%E6%9D%83%E8%A1%A1%E7%9A%84%E8%89%BA%E6%9C%AF.html","title":"权衡的艺术","lang":"zh-CN","frontmatter":{"title":"权衡的艺术","icon":"contrast","order":1,"category":["前端"],"tag":["vue"],"description":"命令式和声明式（视图层框架） 命令式 有如下特点： 自然语言描述能够与代码产生一一对应的关系，更加关注过程 早期流行的jquery就是典型的命令式框架，如下： 声明式 不关注过程，更加关注结果 当下流行的 vue 框架就是声明式的： 性能与可维护性的权衡 声明式代码的性能差于命令式代码的性能 原因如下： 声明式代码比命令式代码多出找出差异的性能消耗 声...","head":[["meta",{"property":"og:url","content":"https://godx-18.github.io/%E9%98%85%E8%AF%BB/Vuejs%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/01-%E6%9D%83%E8%A1%A1%E7%9A%84%E8%89%BA%E6%9C%AF.html"}],["meta",{"property":"og:site_name","content":"烜"}],["meta",{"property":"og:title","content":"权衡的艺术"}],["meta",{"property":"og:description","content":"命令式和声明式（视图层框架） 命令式 有如下特点： 自然语言描述能够与代码产生一一对应的关系，更加关注过程 早期流行的jquery就是典型的命令式框架，如下： 声明式 不关注过程，更加关注结果 当下流行的 vue 框架就是声明式的： 性能与可维护性的权衡 声明式代码的性能差于命令式代码的性能 原因如下： 声明式代码比命令式代码多出找出差异的性能消耗 声..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-07T03:00:15.000Z"}],["meta",{"property":"article:author","content":"GodX"}],["meta",{"property":"article:tag","content":"vue"}],["meta",{"property":"article:modified_time","content":"2023-08-07T03:00:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"权衡的艺术\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-08-07T03:00:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"GodX\\",\\"url\\":\\"https://github.com/GodX-18\\"}]}"]]},"headers":[{"level":2,"title":"命令式和声明式（视图层框架）","slug":"命令式和声明式-视图层框架","link":"#命令式和声明式-视图层框架","children":[{"level":3,"title":"命令式","slug":"命令式","link":"#命令式","children":[]},{"level":3,"title":"声明式","slug":"声明式","link":"#声明式","children":[]}]},{"level":2,"title":"性能与可维护性的权衡","slug":"性能与可维护性的权衡","link":"#性能与可维护性的权衡","children":[]},{"level":2,"title":"虚拟 DOM 的性能到底如何","slug":"虚拟-dom-的性能到底如何","link":"#虚拟-dom-的性能到底如何","children":[{"level":3,"title":"虚拟 DOM 存在的意义","slug":"虚拟-dom-存在的意义","link":"#虚拟-dom-存在的意义","children":[]},{"level":3,"title":"比较 innerHtml 和虚拟 DOM 的性能","slug":"比较-innerhtml-和虚拟-dom-的性能","link":"#比较-innerhtml-和虚拟-dom-的性能","children":[]}]},{"level":2,"title":"运行时和编译时","slug":"运行时和编译时","link":"#运行时和编译时","children":[{"level":3,"title":"纯运行时","slug":"纯运行时","link":"#纯运行时","children":[]},{"level":3,"title":"纯编译时","slug":"纯编译时","link":"#纯编译时","children":[]},{"level":3,"title":"运行时 + 编译时","slug":"运行时-编译时","link":"#运行时-编译时","children":[]}]}],"git":{"createdTime":1686706060000,"updatedTime":1691377215000,"contributors":[{"name":"GodX","email":"1046529973@qq.com","commits":2}]},"readingTime":{"minutes":3.09,"words":927},"filePathRelative":"阅读/Vuejs设计与实现/01-权衡的艺术.md","localizedDate":"2023年6月14日","excerpt":"<h2>命令式和声明式（视图层框架）</h2>\\n<h3>命令式</h3>\\n<p><strong>有如下特点：</strong></p>\\n<ul>\\n<li>自然语言描述能够与代码产生一一对应的关系，更加关注过程</li>\\n<li>早期流行的<code>jquery</code>就是典型的命令式框架，如下：</li>\\n</ul>\\n<div class=\\"language-javascript\\" data-ext=\\"js\\" data-title=\\"js\\"><pre class=\\"language-javascript\\"><code><span class=\\"token function\\">$</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">'#app'</span><span class=\\"token punctuation\\">)</span>\\n  <span class=\\"token punctuation\\">.</span><span class=\\"token function\\">text</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">'hello world'</span><span class=\\"token punctuation\\">)</span>\\n\\t<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">on</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">'click'</span><span class=\\"token punctuation\\">,</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">=&gt;</span> <span class=\\"token punctuation\\">{</span><span class=\\"token function\\">alert</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">'ok'</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">)</span>\\n</code></pre></div>","autoDesc":true}`);export{d as comp,k as data};
