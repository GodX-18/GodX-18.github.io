---
title: 案例
date: 2024-02-04
order: 2
category:
  - 算法
tag:
  - 区间
---

## [汇总区间](https://leetcode.cn/problems/summary-ranges/)

给定一个  **无重复元素** 的 **有序** 整数数组 `nums` 。

返回 ***恰好覆盖数组中所有数字** 的 **最小有序** 区间范围列表* 。也就是说，`nums` 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 `nums` 的数字 `x` 。

列表中的每个区间范围 `[a,b]` 应该按如下格式输出：

- `"a->b"` ，如果 `a != b`
- `"a"` ，如果 `a == b`

**示例 1：**

```
输入：nums = [0,1,2,4,5,7]
输出：["0->2","4->5","7"]
解释：区间范围是：
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"
```

**示例 2：**

```
输入：nums = [0,2,3,4,6,8,9]
输出：["0","2->4","6","8->9"]
解释：区间范围是：
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"
```

**提示：**

- `0 <= nums.length <= 20`
- `-231 <= nums[i] <= 231 - 1`
- `nums` 中的所有值都 **互不相同**
- `nums` 按升序排列

:::tip 解题思路

- 首先，判断输入的数组是否为空，如果为空，就返回一个空数组
- 然后，定义一个答案数组`ans`，和两个指针`L`和`R`，分别指向数组的第一个和第二个元素
- 定义一个辅助函数`handlePush`，用来将`L`和`R-1`之间的连续区间添加到`ans`中，如果`L`和`R-1`相等，就只添加一个元素，否则添加一个范围字符串
- 接着，遍历数组，计算`R`和`R-1`之间的差值`gap`，如果`gap`大于1，说明`L`和`R-1`之间的区间已经结束，就调用`handlePush`函数，然后将`L`移动到`R`的位置
- 最后，将`L`和`R-1`之间的最后一个区间也添加到`ans`中，返回`ans`数组

:::

:::info 优化空间

循环的条件是`R < nums.length`，所以当`R`等于`nums.length`时，循环就停止了，此时`L`和`R-1`之间的区间还没有被处理，所以需要在循环外面再调用一次`handlePush`函数，将最后一个区间也加入到`ans`数组中。这样就可以保证所有的连续区间都被包含在结果中了。

:::

:::code-tabs#shell

@tab self

```js
/**
 * @param {number[]} nums
 * @return {string[]}
 */
var summaryRanges = function (nums) {
    if (nums.length === 0) return []
    const ans = [];
    let L = 0;
    let R = 1;
    function handlePush() {
        if (nums[L] === nums[R - 1]) {
            ans.push(nums[L].toString())
        } else {
            ans.push(nums[L] + '->' + nums[R - 1]);
        }
    }
    while (R < nums.length) {
        const gap = nums[R] - nums[R - 1];
        if (gap > 1) {
            handlePush()
            L = R;
        }
        R++;
    }
    handlePush()
    return ans
};
```

@tab 优化后

```js
function summaryRanges(nums) {
    // 用于存储最终结果的数组
    let ans = [];
    // 初始化迭代器 i 为 0，表示从数组的第一个元素开始遍历
    let i = 0;
    // 获取数组的长度，方便后续迭代使用
    let n = nums.length;

    // 使用 while 循环进行迭代，直到遍历完整个数组
    while (i < n) {
        // 记录当前连续范围的起始索引
        let start = i;

        // 使用内部的 while 循环，查找当前连续范围的结束索引
        while (i < n - 1 && nums[i] + 1 === nums[i + 1]) {
            i++;
        }
        // 将当前连续范围的起始值和结束值组成字符串，加入结果数组
        ans.push(i === start ? `${nums[start]}` : `${nums[start]}->${nums[i]}`);
        
        // 继续迭代下一个元素
        i++;
    }

    // 返回整理好的结果数组
    return ans;
}
```

:::