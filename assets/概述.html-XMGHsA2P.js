import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o as r,c as o,b as e,e as n,d as i,a as s}from"./app-oXp7PBbS.js";const d={},p=s(`<h2 id="什么是链表" tabindex="-1"><a class="header-anchor" href="#什么是链表"><span>什么是链表</span></a></h2><p>链表是一种物理存储单元上非连续，非顺序的存储结构。链表中的元素不一定是顺序存储的，为了保证链表中元素的连续性，一般使用一个指针来找到下一个元素。链表不具有随机访问的特性，在链表中根据索引来查找元素只能从头开始，它的时间复杂度是O(n)。</p><figure><img src="https://raw.githubusercontent.com/GodX-18/picBed/main/image-20240321154211088.png" alt="image-20240321154211088" tabindex="0" loading="lazy"><figcaption>image-20240321154211088</figcaption></figure><p>如上图所示，链表的节点包括两个部分：</p><ol><li>存储数据元素的数据域（内存空间）</li><li>存储指向下一个节点地址的指针域</li></ol><p>链表可以动态地进行存储分配，也就是说，链表是一个功能极为强大的数组，他可以在节点中定义多种数据类型，还可以根据需要随意增添，删除，插入节点。</p><p>链表的种类包括单链表、双链表、单向循环链表和双向循环链表。对于链表的每一个节点，我们可以使用结构体进行设计，其主要内容有数据元素和一个指向下一个节点的指针。链表的初始化主要完成以下工作：创建一个单链表的前置节点并向后逐步添加节点，一般指的是申请节点的空间，同时对一个节点赋空值 (null)。</p><p>总的来说，链表是一种灵活的数据结构，它允许我们在任何位置插入和删除元素，而不需要像数组那样移动大量的元素。然而，这种灵活性是以牺牲更多的内存为代价的。</p><h2 id="链表和数组的差异" tabindex="-1"><a class="header-anchor" href="#链表和数组的差异"><span>链表和数组的差异</span></a></h2><p>链表和数组是两种基本的数据结构，它们在内存存储上的表现不一样，所以也有各自的特点。</p><p><strong>数组</strong>的特点：</p><ol><li>在内存中，数组是一块连续的区域。</li><li>数组需要预留空间，在使用前需要提前申请所占内存的大小。</li><li>数组支持随机访问，时间复杂度为O(1)。</li><li>在数组起始位置处，插入数据和删除数据效率低。插入数据时，待插入位置的元素和它后面的所有元素都需要向后搬移。</li></ol><p><strong>链表</strong>的特点：</p><ol><li>在内存中，链表的元素可以在任意地方，空间是分散的，不需要连续。</li><li>链表中的元素都会两个属性，一个是元素的值，另一个是指针，此指针标记了下一个元素的地址。</li><li>查找数据时效率低,时间复杂度为O(n)，因为链表的空间是分散的，所以不具有随机访问性。</li><li>任意位置插入元素和删除元素效率较高，时间复杂度为O(1)。</li></ol><p>总的来说，对于想要快速访问数据，不经常有插入和删除元素的时候，选择数组；对于需要经常的插入和删除元素，而对访问元素时的效率没有很高要求的话，选择链表。</p><h2 id="链表的基本操作" tabindex="-1"><a class="header-anchor" href="#链表的基本操作"><span>链表的基本操作</span></a></h2><h3 id="插入" tabindex="-1"><a class="header-anchor" href="#插入"><span>插入</span></a></h3><p>插入只需要考虑要插入位置前驱节点和后继节点（双向链表的情况下需要更新后继节点）即可，其他节点不受影响，因此在给定指针的情况下插入的操作时间复杂度为<code>O(1)</code>。这里给定指针中的指针指的是插入位置的前驱节点，伪代码如下：</p><div class="language-tex line-numbers-mode" data-ext="tex" data-title="tex"><pre class="language-tex"><code>temp = 待插入位置的前驱节点.next
待插入位置的前驱节点.next = 待插入指针
待插入指针.next = temp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="删除" tabindex="-1"><a class="header-anchor" href="#删除"><span>删除</span></a></h3><p>只需要将需要删除的节点的前驱指针的 next 指针修正为其下下个节点即可，注意考虑<strong>边界条件</strong>。伪代码如下：</p><div class="language-tex line-numbers-mode" data-ext="tex" data-title="tex"><pre class="language-tex"><code>待删除位置的前驱节点.next = 待删除位置的前驱节点.next.next
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="遍历" tabindex="-1"><a class="header-anchor" href="#遍历"><span>遍历</span></a></h3><p>遍历比较简单，直接上伪代码。</p><div class="language-tex line-numbers-mode" data-ext="tex" data-title="tex"><pre class="language-tex"><code>当前指针 =  头指针
while 当前节点不为空 <span class="token punctuation">{</span>
   print(当前节点)
   当前指针 = 当前指针.next
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="链表结构的优缺点" tabindex="-1"><a class="header-anchor" href="#链表结构的优缺点"><span>链表结构的优缺点</span></a></h2><p>链表作为一种基本的数据结构，有其独特的优点和缺点。</p><p><strong>优点</strong>：</p><ol><li><strong>动态扩展性</strong>：链表是一种动态数据结构，可以在运行时根据需要增加或减少节点，非常方便快捷。</li><li><strong>插入和删除效率高</strong>：在链表中插入和删除节点的时间复杂度为O(1)，远小于数组的O(n)。这是因为链表中的元素不需要连续存储，可以直接通过指针进行操作。</li><li><strong>节省空间</strong>：链表中的节点只在需要时才会被分配内存，因此可以有效利用内存资源。</li><li><strong>支持双向操作</strong>：链表中的每个节点都有指向下一个节点的指针，因此可以很容易地实现双向操作，比如回溯算法。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>访问元素效率低</strong>：相对于数组的直接索引访问，链表需要从头节点开始逐个访问节点，访问某个特定元素的时间复杂度为O(n)。</li><li><strong>内存消耗</strong>：由于链表中的每个节点都需要存储指向下一个节点的指针，因此链表的内存消耗会比数组大。</li></ol><p>总的来说，链表在处理大量数据、需要频繁插入和删除操作的场景下具有优势，但在需要频繁访问特定元素的场景下，数组可能会更有优势。</p><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h2><p>链表的操作问题，一般题目中不允许我们修改节点的值，而只能修改节点的指向操作。</p><p>思路通常都不难，写对链表问题的技巧是：一定要先想清楚思路，并且必要的时候在草稿纸上画图，理清「穿针引线」的先后步骤，然后再编码。</p><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接"><span>参考链接</span></a></h2>`,36),c={href:"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",target:"_blank",rel:"noopener noreferrer"},h={href:"https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/thinkings/linked-list",target:"_blank",rel:"noopener noreferrer"},g={href:"https://zhuanlan.zhihu.com/p/249144171",target:"_blank",rel:"noopener noreferrer"};function m(u,v){const t=l("ExternalLinkIcon");return r(),o("div",null,[p,e("ul",null,[e("li",null,[e("a",c,[n("链表 - 维基百科，自由的百科全书 (wikipedia.org)"),i(t)])]),e("li",null,[e("a",h,[n("链表专题 | 力扣加加 - 努力做西湖区最好的算法题解 (gitbook.io)"),i(t)])]),e("li",null,[e("a",g,[n("一口气搞懂「链表」，就靠这20+张图了 - 知乎 (zhihu.com)"),i(t)])])])])}const f=a(d,[["render",m],["__file","概述.html.vue"]]),_=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E6%A6%82%E8%BF%B0.html","title":"概述","lang":"zh-CN","frontmatter":{"title":"概述","date":"2024-03-18T00:00:00.000Z","order":1,"category":["算法"],"tag":["链表"],"description":"什么是链表 链表是一种物理存储单元上非连续，非顺序的存储结构。链表中的元素不一定是顺序存储的，为了保证链表中元素的连续性，一般使用一个指针来找到下一个元素。链表不具有随机访问的特性，在链表中根据索引来查找元素只能从头开始，它的时间复杂度是O(n)。 image-20240321154211088image-20240321154211088 如上图所示...","head":[["meta",{"property":"og:url","content":"https://godx-18.github.io/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E6%A6%82%E8%BF%B0.html"}],["meta",{"property":"og:site_name","content":"烜"}],["meta",{"property":"og:title","content":"概述"}],["meta",{"property":"og:description","content":"什么是链表 链表是一种物理存储单元上非连续，非顺序的存储结构。链表中的元素不一定是顺序存储的，为了保证链表中元素的连续性，一般使用一个指针来找到下一个元素。链表不具有随机访问的特性，在链表中根据索引来查找元素只能从头开始，它的时间复杂度是O(n)。 image-20240321154211088image-20240321154211088 如上图所示..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/GodX-18/picBed/main/image-20240321154211088.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-25T15:02:52.000Z"}],["meta",{"property":"article:author","content":"GodX"}],["meta",{"property":"article:tag","content":"链表"}],["meta",{"property":"article:published_time","content":"2024-03-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-25T15:02:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"概述\\",\\"image\\":[\\"https://raw.githubusercontent.com/GodX-18/picBed/main/image-20240321154211088.png\\"],\\"datePublished\\":\\"2024-03-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-25T15:02:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"GodX\\",\\"url\\":\\"https://github.com/GodX-18\\"}]}"]]},"headers":[{"level":2,"title":"什么是链表","slug":"什么是链表","link":"#什么是链表","children":[]},{"level":2,"title":"链表和数组的差异","slug":"链表和数组的差异","link":"#链表和数组的差异","children":[]},{"level":2,"title":"链表的基本操作","slug":"链表的基本操作","link":"#链表的基本操作","children":[{"level":3,"title":"插入","slug":"插入","link":"#插入","children":[]},{"level":3,"title":"删除","slug":"删除","link":"#删除","children":[]},{"level":3,"title":"遍历","slug":"遍历","link":"#遍历","children":[]}]},{"level":2,"title":"链表结构的优缺点","slug":"链表结构的优缺点","link":"#链表结构的优缺点","children":[]},{"level":2,"title":"解题思路","slug":"解题思路","link":"#解题思路","children":[]},{"level":2,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"git":{"createdTime":1710740871000,"updatedTime":1711378972000,"contributors":[{"name":"GodX","email":"1046529973@qq.com","commits":3}]},"readingTime":{"minutes":5.35,"words":1605},"filePathRelative":"算法/链表/概述.md","localizedDate":"2024年3月18日","excerpt":"<h2>什么是链表</h2>\\n<p>链表是一种物理存储单元上非连续，非顺序的存储结构。链表中的元素不一定是顺序存储的，为了保证链表中元素的连续性，一般使用一个指针来找到下一个元素。链表不具有随机访问的特性，在链表中根据索引来查找元素只能从头开始，它的时间复杂度是O(n)。</p>\\n<figure><img src=\\"https://raw.githubusercontent.com/GodX-18/picBed/main/image-20240321154211088.png\\" alt=\\"image-20240321154211088\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>image-20240321154211088</figcaption></figure>","autoDesc":true}');export{f as comp,_ as data};
