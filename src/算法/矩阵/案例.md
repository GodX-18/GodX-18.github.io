---
title: 案例
date: 2024-01-17
order: 2
category:
  - 算法
tag:
  - 矩阵
---

## [有效的数独(中)](https://leetcode.cn/problems/valid-sudoku/)

请你判断一个 `9 x 9` 的数独是否有效。只需要 **根据以下规则** ，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

**注意：**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 空白格用 `'.'` 表示。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)

```
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true
```

**示例 2：**

```
输入：board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

**提示：**

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` 是一位数字（`1-9`）或者 `'.'`

:::tip 解题思路

1. 使用哈希表分别跟踪每一行、每一列以及每个3x3宫内出现的数字。
2. 对于数独板上的每个元素，如果是数字，检查其是否在其所属的行、列或宫内重复出现。
3. 如果发现重复，则说明数独解决方案无效，函数返回 `false`。
4. 如果整个板遍历完毕，没有发现重复数字，则数独方案有效，函数返回 `true`。

算法流程：

1. 初始化三个哈希表，用来存储每个行、每个列、每个宫的数字出现情况。
2. 依次遍历数独棋盘上的每个格子，进行以下操作：
   - 如果格子是空的（`.`），继续检查下一个格子。
   - 如果格子中有数字（`1`到`9`），则：
     - 计算它所在的宫的索引号。
     - 检查当前数字是否已经在该行、该列、或该宫中存储过。这一步通过查找哈希表来完成，键的形式分别是`行号-数字`、`列号-数字`、`宫索引-数字`。
3. 如果在步骤2中发现某个数字在同行、同列或同宫中已存在，立刻返回 `false`。
4. 如果所有格子都检查完毕，没有发现问题，返回 `true`。

通过上述逻辑，代码有效地遍历了所有格子，且有效避免了重复计算和不必要的检查，保证了算法的效率。这个算法的时间复杂度为 O(n^2)，其中 n 是数独每一行或列的长度，在此案例中为常数9，所以实际是 O(1)（固定大小的棋盘）。

:::

```js
// 定义函数isValidSudoku来判断一个9x9的数独板是否有效
var isValidSudoku = function (board) {
    // 初始化三个哈希表来记录行、列以及3x3子格子中的数字是否出现过
    let rows = {};
    let columns = {};
    let boxes = {};

    // 两层循环遍历数独的每个格子
    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            // 提取当前坐标格子中的数字
            let num = board[i][j];

            // 如果当前格子有数字（不是'.'），则检查该数字是否在其所在的行、列或3x3子格子中重复
            if (num != '.') {
                // 计算3x3子格子的索引
                let boxIndex = parseInt(i / 3) * 3 + parseInt(j / 3);
                
                // 构建在哈希表中检查的键
                // 对于行来说，使用行号-数字作为键
                // 对于列来说，使用列号-数字作为键
                // 对于3x3子格子来说，使用盒子索引-数字作为键
                // 检查数字是否已经在所属行、列或3x3子格子中出现过
                if (rows[i + '-' + num] || columns[j + '-' + num] || boxes[boxIndex + '-' + num]) {
                    // 如果任何检查为真，则立即返回false，因为数独无效
                    return false;
                }

                // 在哈希表中记录当前数字已在对应的行、列和3x3子格子中出现过
                rows[i + '-' + num] = true;
                columns[j + '-' + num] = true;
                boxes[boxIndex + '-' + num] = true;
            }
        }
    }
    // 如果所有的格子都检查完毕且没有发现重复，说明数独有效，返回true
    return true;
};

```

## [螺旋矩阵(中)](https://leetcode.cn/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

:::tip 解题思路

根据题目示例 matrix = [[1,2,3],[4,5,6],[7,8,9]] 的对应输出 [1,2,3,6,9,8,7,4,5] 可以发现，顺时针打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。

因此，考虑设定矩阵的 “左、上、右、下” 四个边界，模拟以上矩阵遍历顺序。

![image-20240118102553791](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20240118102553791.png)

  算法步骤：
1. 空值处理： 当 matrix 为空时，直接返回空列表 [] 即可。
2. 初始化： 矩阵 左、右、上、下 四个边界 l , r , t , b ，用于打印的结果列表 res 。
3. 循环打印： “从左向右、从上向下、从右向左、从下向上” 四个方向循环打印。
   1. 根据边界打印，即将元素按顺序添加至列表 res 尾部。
   2. 边界向内收缩 1 （代表已被打印）。
   3. 判断边界是否相遇（是否打印完毕），若打印完毕则跳出。
4. 返回值： 返回 res 即可。

![image-20240118102416298](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20240118102416298.png)

:::

```js
/*
  函数：spiralOrder
  参数：matrix - 二维数组，表示一个矩阵
  返回值：以螺旋顺序遍历矩阵的结果数组
*/

function spiralOrder(matrix) {
    if (!matrix.length) return []; // 如果矩阵为空，直接返回空数组
    let l = 0, r = matrix[0].length - 1, t = 0, b = matrix.length - 1, res = []; // 初始化边界指针和结果数组
    while (true) {
        // 从左到右遍历上边界
        for (let i = l; i <= r; i++) res.push(matrix[t][i]);
        t += 1; // 上边界下移一行
        if (t > b) break; // 如果上边界超过下边界，则结束循环

        // 从上到下遍历右边界
        for (let i = t; i <= b; i++) res.push(matrix[i][r]);
        r -= 1; // 右边界左移一列
        if (l > r) break; // 如果左边界超过右边界，则结束循环

        // 从右到左遍历下边界
        for (let i = r; i >= l; i--) res.push(matrix[b][i]);
        b -= 1; // 下边界上移一行
        if (t > b) break; // 如果上边界超过下边界，则结束循环

        // 从下到上遍历左边界
        for (let i = b; i >= t; i--) res.push(matrix[i][l]);
        l += 1; // 左边界右移一列
        if (l > r) break; // 如果左边界超过右边界，则结束循环
    }
    return res; // 返回螺旋遍历结果数组
}

```

## [旋转图像(中)](https://leetcode.cn/problems/rotate-image/)

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)

```
输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

**提示：**

- `n == matrix.length == matrix[i].length`
- `1 <= n <= 20`
- `-1000 <= matrix[i][j] <= 1000`

:::tip 解题思路

**方法一：辅助矩阵**

如下图所示，矩阵顺时针旋转 90º 后，可找到以下规律：

「第 i 行」元素旋转到「第 n−1−i 列」元素；
「第 j 列」元素旋转到「第 j 行」元素；
因此，对于矩阵任意第 i 行、第 j 列元素 `matrix[i][j]`，矩阵旋转 90º 后「元素位置旋转公式」为：

![image-20240119102020382](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20240119102020382.png) 

**方法二：原地修改**

![image-20240119103233716](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20240119103233716.png)

![image-20240119103321532](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20240119103321532.png)

![image-20240119104714647](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20240119104714647.png)

![image-20240119104739491](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20240119104739491.png)

**方法三：用翻转代替旋转**

![image-20240119105448126](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20240119105448126.png)

![image-20240119105507295](https://raw.githubusercontent.com/GodX-18/picBed/main/image-20240119105507295.png)

:::

:::code-tabs#shell

@tab 辅助矩阵

```js
var rotate = function (matrix) {
    const len = matrix.length;
    // 深拷贝
    const ans = JSON.parse(JSON.stringify(matrix));
    for (let i = 0; i < len; i++) {
        for (let j = 0; j < len; j++) {
            matrix[j][len - 1 - i] = ans[i][j]
        }
    }
    return ans;
};
```

@tab 原地修改

```js
// 定义一个函数，用于将一个n×n的矩阵顺时针旋转90度，不使用额外的空间
var rotate = function(matrix) {
    // 获取矩阵的长度
    const n = matrix.length;
    // 遍历矩阵的每一层，从外层到内层
    for (let i = 0; i < Math.floor(n / 2); ++i) {
        // 遍历该层的前n-1-i*2个元素，从左上角开始
        for (let j = 0; j < Math.floor((n + 1) / 2); ++j) {
            // 保存当前元素到一个临时变量
            const temp = matrix[i][j];
            // 将当前元素与它顺时针旋转后的位置的元素交换，共四次交换
            matrix[i][j] = matrix[n - j - 1][i];
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
            matrix[j][n - i - 1] = temp;
        }
    }
};

```

@tab 用翻转代替旋转

```js
var rotate = function(matrix) {
    const n = matrix.length;
    // 水平翻转
    for (let i = 0; i < Math.floor(n / 2); i++) {
        for (let j = 0; j < n; j++) {
            [matrix[i][j], matrix[n - i - 1][j]] = [matrix[n - i - 1][j], matrix[i][j]];
        }
    }
    // 主对角线翻转
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < i; j++) {
            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
        }
    }
};
```

:::



