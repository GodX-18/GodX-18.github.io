import{_ as u}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o as r,c as d,b as n,e as s,d as a,w as e,a as o}from"./app-oXp7PBbS.js";const k={},m={id:"长度最小的子数组-中",tabindex:"-1"},v={class:"header-anchor",href:"#长度最小的子数组-中"},b={href:"https://leetcode.cn/problems/minimum-size-subarray-sum/",target:"_blank",rel:"noopener noreferrer"},g=o(`<p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度**。**如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：target = 4, nums = [1,4,4]
输出：1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><div class="hint-container tip"><p class="hint-container-title">解题思路</p><p>如果想到了滑动数组和双指针，那就可以一步一步来，比如说先创建双指针，然后思考如何让它两边可以动起来，那就可以有一个sum来计算总数是否超过target，如果超过了，那么左指针就往右移动即l++，再比较并记录答案，最后返回记录的答案即可。</p></div><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">,</span> nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 初始化双指针、当前子数组和以及最小长度</span>
    <span class="token keyword">let</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">Infinity</span><span class="token punctuation">;</span>

    <span class="token comment">// 移动 end 指针，扩展当前子数组</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token comment">// 若当前子数组的和大于等于目标值 s，则尝试缩小子数组长度</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;=</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 更新最小长度</span>
            ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 移动 start 指针，缩小当前子数组</span>
            sum <span class="token operator">-=</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>
            start<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 继续扩展当前子数组</span>
        end<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 若最小长度仍然为初始值 Infinity，则说明不存在符合条件的子数组</span>
    <span class="token keyword">return</span> ans <span class="token operator">===</span> <span class="token number">Infinity</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,14),h={id:"无重复字符的最长子串-中",tabindex:"-1"},w={class:"header-anchor",href:"#无重复字符的最长子串-中"},f={href:"https://leetcode.cn/problems/longest-substring-without-repeating-characters/",target:"_blank",rel:"noopener noreferrer"},y=o(`<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: s = &quot;abcabcbb&quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: s = &quot;bbbbb&quot;
输出: 1
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: s = &quot;pwwkew&quot;
输出: 3
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><div class="hint-container tip"><p class="hint-container-title">解题思路</p><ol><li>初始化变量：<code>ans</code> 用于存储最长子串的长度，<code>left</code> 作为滑动窗口的左边界，<code>window</code> 集合用于维护窗口内的唯一字符。</li><li>通过右指针 (<code>right</code>) 从字符串的开头迭代到结尾。</li><li>对于右边界的每个字符 <code>c</code>： <ul><li>检查 <code>c</code> 是否已经在窗口集合中。</li><li>如果是，则将窗口的左边界 (<code>left</code>) 向右移动，直到窗口不再包含 <code>c</code> 的重复字符。在左边界移动时从集合中移除字符。</li></ul></li><li>将当前字符 <code>c</code> 添加到窗口集合中。</li><li>使用当前窗口的最大长度更新 <code>ans</code> 变量 (<code>right - left + 1</code>)。</li><li>重复步骤 3-5 对字符串中的所有字符执行。</li><li>返回 <code>ans</code> 的最终值，表示给定字符串中没有重复字符的最长子串的长度。</li></ol></div><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 计算给定字符串中无重复字符的最长子串长度的函数</span>
<span class="token keyword">var</span> <span class="token function-variable function">lengthOfLongestSubstring</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 存储最长子串长度的变量</span>
    <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 窗口左边界的指针</span>
    <span class="token keyword">const</span> window <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用 Set 数据结构维护窗口内的字符集合</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> right<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> c <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 当前窗口右边界的字符</span>

        <span class="token comment">// 当窗口内已存在当前字符 c 时，移动左边界，确保窗口内无重复元素</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            window<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除窗口左边界的字符，并将左边界向右移动</span>
        <span class="token punctuation">}</span>

        window<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将当前字符 c 加入窗口内</span>
        ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新最长子串长度，取当前窗口长度与已知最大长度的较大值</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> ans<span class="token punctuation">;</span> <span class="token comment">// 返回最长子串长度</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,11),q={id:"串联所有单词的子串-难",tabindex:"-1"},x={class:"header-anchor",href:"#串联所有单词的子串-难"},_={href:"https://leetcode.cn/problems/substring-with-concatenation-of-all-words/",target:"_blank",rel:"noopener noreferrer"},E=o(`<p>给定一个字符串 <code>s</code> 和一个字符串数组 <code>words</code><strong>。</strong> <code>words</code> 中所有字符串 <strong>长度相同</strong>。</p><p><code>s</code> 中的 <strong>串联子串</strong> 是指一个包含 <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p><ul><li>例如，如果 <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>， 那么 <code>&quot;abcdef&quot;</code>， <code>&quot;abefcd&quot;</code>，<code>&quot;cdabef&quot;</code>， <code>&quot;cdefab&quot;</code>，<code>&quot;efabcd&quot;</code>， 和 <code>&quot;efcdab&quot;</code> 都是串联子串。 <code>&quot;acdbef&quot;</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li></ul><p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]
输出：[0,9]
解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。
子串 &quot;barfoo&quot; 开始位置是 0。它是 words 中以 [&quot;bar&quot;,&quot;foo&quot;] 顺序排列的连接。
子串 &quot;foobar&quot; 开始位置是 9。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。
输出顺序无关紧要。返回 [9,0] 也是可以的。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]
输出：[]
解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。
s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。
所以我们返回一个空数组。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：s = &quot;barfoofoobarthefoobarman&quot;, words = [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]
输出：[6,9,12]
解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。
子串 &quot;foobarthe&quot; 开始位置是 6。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;] 顺序排列的连接。
子串 &quot;barthefoo&quot; 开始位置是 9。它是 words 中以 [&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;] 顺序排列的连接。
子串 &quot;thefoobar&quot; 开始位置是 12。它是 words 中以 [&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>1 &lt;= words.length &lt;= 5000</code></li><li><code>1 &lt;= words[i].length &lt;= 30</code></li><li><code>words[i]</code> 和 <code>s</code> 由小写英文字母组成</li></ul><div class="hint-container tip"><p class="hint-container-title">解题思路</p><p>整体思路就是利用滑动窗口，关键就是在于如何判断判断子串是否符合条件。</p><ol><li><strong>初始化：</strong> 设置窗口的左右指针 <code>left</code> 和 <code>right</code>，初始都指向字符串的开头，然后遍历每个可能的起始位置（单词的长度范围）。</li><li><strong>词频表：</strong> 维护两个词频表，<code>wordMap</code> 用于记录 words 中每个单词的出现次数，<code>currentWordMap</code> 用于记录当前窗口内单词的出现次数。</li><li><strong>滑动窗口：</strong> 从每个可能的起始位置开始，移动右指针 <code>right</code>，依次获取当前窗口内的单词。如果当前单词不在 <code>wordMap</code> 中，说明窗口内的单词无法构成串联子串，重置 <code>currentWordMap</code> 和左指针 <code>left</code>。</li><li><strong>更新词频表：</strong> 更新 <code>currentWordMap</code> 中当前单词的出现次数。然后，通过移动左指针 <code>left</code>，排除多余的单词，确保窗口内的单词都符合要求。</li><li><strong>判断是否找到串联子串：</strong> 在窗口滑动的过程中，判断是否找到了符合条件的串联子串，即窗口的长度是否等于 words 中所有单词连接起来的长度。</li><li><strong>记录结果：</strong> 如果找到了符合条件的串联子串，记录当前窗口的左指针 <code>left</code>，表示找到一个匹配的起始位置。</li><li><strong>遍历完成：</strong> 遍历完成后，返回所有记录的起始位置作为结果。</li></ol></div><div class="hint-container info"><p class="hint-container-title">优化空间(self)</p><ul><li><strong>性能考虑：</strong> 使用了 <code>slice</code> 和 <code>padEnd</code> 来分割字符串，这可能涉及一些额外的复制操作。在处理大型字符串时，可能会影响性能。而在我的实现中，直接使用了 <code>substr</code>。</li><li><strong>可读性：</strong> 一些变量名和函数名可以更具体一些，使得代码更易于理解。例如，<code>judeInclude</code> 可以改成 <code>isSubarrayValid</code>，<code>areArraysEqual</code> 可以改成 <code>areArraysPermutations</code>。</li><li><strong>避免重复计算：</strong> 在 <code>areArraysEqual</code> 中，使用了两次 <code>countElements</code>，可以考虑在外部先计算一次并传入两次使用，避免重复计算。</li><li><strong>逻辑调整：</strong> 在 <code>areArraysEqual</code> 中，可以先比较数组长度，再比较元素，这样可能会更高效。</li></ul></div>`,14),A=n("div",{class:"language-javascript line-numbers-mode","data-ext":"js","data-title":"js"},[n("pre",{class:"language-javascript"},[n("code",null,[n("span",{class:"token comment"},"// 主程序"),s(`
`),n("span",{class:"token keyword"},"var"),s(),n("span",{class:"token function-variable function"},"findSubstring"),s(),n("span",{class:"token operator"},"="),s(),n("span",{class:"token keyword"},"function"),s(),n("span",{class:"token punctuation"},"("),n("span",{class:"token parameter"},[s("s"),n("span",{class:"token punctuation"},","),s(" words")]),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token keyword"},"let"),s(),n("span",{class:"token constant"},"L"),s(),n("span",{class:"token operator"},"="),s(),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token keyword"},"let"),s(),n("span",{class:"token constant"},"R"),s(),n("span",{class:"token operator"},"="),s(" words"),n("span",{class:"token punctuation"},"."),s("length "),n("span",{class:"token operator"},"*"),s(" words"),n("span",{class:"token punctuation"},"["),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},"]"),n("span",{class:"token punctuation"},"."),s("length "),n("span",{class:"token operator"},"-"),s(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token keyword"},"let"),s(" ans "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token punctuation"},"["),n("span",{class:"token punctuation"},"]"),s(`
    `),n("span",{class:"token keyword"},"while"),s(),n("span",{class:"token punctuation"},"("),n("span",{class:"token constant"},"R"),s(),n("span",{class:"token operator"},"<"),s(" s"),n("span",{class:"token punctuation"},"."),s("length"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
        `),n("span",{class:"token comment"},"// 判断判断子串是否符合条件"),s(`
        `),n("span",{class:"token keyword"},"if"),s(),n("span",{class:"token punctuation"},"("),n("span",{class:"token function"},"judeInclude"),n("span",{class:"token punctuation"},"("),s("s"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"slice"),n("span",{class:"token punctuation"},"("),n("span",{class:"token constant"},"L"),n("span",{class:"token punctuation"},","),s(),n("span",{class:"token constant"},"R"),s(),n("span",{class:"token operator"},"+"),s(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},","),s(" words"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
            ans`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"push"),n("span",{class:"token punctuation"},"("),n("span",{class:"token constant"},"L"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
        `),n("span",{class:"token punctuation"},"}"),s(`
        `),n("span",{class:"token constant"},"L"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},";"),s(`
        `),n("span",{class:"token constant"},"R"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token punctuation"},"}"),s(`
    `),n("span",{class:"token keyword"},"return"),s(" ans"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),n("span",{class:"token punctuation"},";"),s(`

`),n("span",{class:"token keyword"},"function"),s(),n("span",{class:"token function"},"judeInclude"),n("span",{class:"token punctuation"},"("),n("span",{class:"token parameter"},[s("substr"),n("span",{class:"token punctuation"},","),s(" str")]),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token keyword"},"const"),s(" arr "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token function"},"splitString"),n("span",{class:"token punctuation"},"("),s("substr"),n("span",{class:"token punctuation"},","),s(" str"),n("span",{class:"token punctuation"},"["),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},"]"),n("span",{class:"token punctuation"},"."),s("length"),n("span",{class:"token punctuation"},")"),s(`
    `),n("span",{class:"token keyword"},"return"),s(),n("span",{class:"token function"},"areArraysEqual"),n("span",{class:"token punctuation"},"("),s("arr"),n("span",{class:"token punctuation"},","),s("str"),n("span",{class:"token punctuation"},")"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`

`),n("span",{class:"token comment"},"// 辅助函数，统计一个数组中每个元素出现的次数"),s(`
`),n("span",{class:"token keyword"},"function"),s(),n("span",{class:"token function"},"countElements"),n("span",{class:"token punctuation"},"("),n("span",{class:"token parameter"},"arr"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token keyword"},"return"),s(" arr"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"reduce"),n("span",{class:"token punctuation"},"("),n("span",{class:"token punctuation"},"("),n("span",{class:"token parameter"},[s("obj"),n("span",{class:"token punctuation"},","),s(" element")]),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token operator"},"=>"),s(),n("span",{class:"token punctuation"},"{"),s(`
        obj`),n("span",{class:"token punctuation"},"["),s("element"),n("span",{class:"token punctuation"},"]"),s(),n("span",{class:"token operator"},"="),s(),n("span",{class:"token punctuation"},"("),s("obj"),n("span",{class:"token punctuation"},"["),s("element"),n("span",{class:"token punctuation"},"]"),s(),n("span",{class:"token operator"},"||"),s(),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token operator"},"+"),s(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},";"),s(`
        `),n("span",{class:"token keyword"},"return"),s(" obj"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token punctuation"},"}"),n("span",{class:"token punctuation"},","),s(),n("span",{class:"token punctuation"},"{"),n("span",{class:"token punctuation"},"}"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`

`),n("span",{class:"token comment"},"// 判断两个数组是否完全相等"),s(`
`),n("span",{class:"token keyword"},"function"),s(),n("span",{class:"token function"},"areArraysEqual"),n("span",{class:"token punctuation"},"("),n("span",{class:"token parameter"},[s("arr1"),n("span",{class:"token punctuation"},","),s(" arr2")]),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token keyword"},"const"),s(" count1 "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token function"},"countElements"),n("span",{class:"token punctuation"},"("),s("arr1"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token keyword"},"const"),s(" count2 "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token function"},"countElements"),n("span",{class:"token punctuation"},"("),s("arr2"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token keyword"},"for"),s(),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"const"),s(" key "),n("span",{class:"token keyword"},"in"),s(" count1"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
        `),n("span",{class:"token keyword"},"if"),s(),n("span",{class:"token punctuation"},"("),n("span",{class:"token operator"},"!"),s("count2"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"hasOwnProperty"),n("span",{class:"token punctuation"},"("),s("key"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token operator"},"||"),s(" count1"),n("span",{class:"token punctuation"},"["),s("key"),n("span",{class:"token punctuation"},"]"),s(),n("span",{class:"token operator"},"!=="),s(" count2"),n("span",{class:"token punctuation"},"["),s("key"),n("span",{class:"token punctuation"},"]"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
            `),n("span",{class:"token keyword"},"return"),s(),n("span",{class:"token boolean"},"false"),n("span",{class:"token punctuation"},";"),s(`
        `),n("span",{class:"token punctuation"},"}"),s(`
    `),n("span",{class:"token punctuation"},"}"),s(`
    `),n("span",{class:"token keyword"},"return"),s(),n("span",{class:"token boolean"},"true"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`

`),n("span",{class:"token comment"},"// 分割字符串"),s(`
`),n("span",{class:"token keyword"},"function"),s(),n("span",{class:"token function"},"splitString"),n("span",{class:"token punctuation"},"("),n("span",{class:"token parameter"},[s("str"),n("span",{class:"token punctuation"},","),s(" c")]),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token keyword"},"const"),s(" arr "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token punctuation"},"["),n("span",{class:"token punctuation"},"]"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token keyword"},"for"),s(),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"let"),s(" i "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},";"),s(" i "),n("span",{class:"token operator"},"<"),s(" str"),n("span",{class:"token punctuation"},"."),s("length"),n("span",{class:"token punctuation"},";"),s(" i "),n("span",{class:"token operator"},"+="),s(" c"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
        `),n("span",{class:"token keyword"},"const"),s(" sub "),n("span",{class:"token operator"},"="),s(" str"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"slice"),n("span",{class:"token punctuation"},"("),s("i"),n("span",{class:"token punctuation"},","),s(" i "),n("span",{class:"token operator"},"+"),s(" c"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"padEnd"),n("span",{class:"token punctuation"},"("),s("c"),n("span",{class:"token punctuation"},","),s(),n("span",{class:"token string"},'" "'),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
        arr`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"push"),n("span",{class:"token punctuation"},"("),s("sub"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token punctuation"},"}"),s(`
    `),n("span",{class:"token keyword"},"return"),s(" arr"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),j=n("div",{class:"language-javascript line-numbers-mode","data-ext":"js","data-title":"js"},[n("pre",{class:"language-javascript"},[n("code",null,[n("span",{class:"token keyword"},"function"),s(),n("span",{class:"token function"},"findSubstring"),n("span",{class:"token punctuation"},"("),n("span",{class:"token parameter"},[s("s"),n("span",{class:"token punctuation"},","),s(" words")]),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token keyword"},"if"),s(),n("span",{class:"token punctuation"},"("),s("s"),n("span",{class:"token punctuation"},"."),s("length "),n("span",{class:"token operator"},"==="),s(),n("span",{class:"token number"},"0"),s(),n("span",{class:"token operator"},"||"),s(" words"),n("span",{class:"token punctuation"},"."),s("length "),n("span",{class:"token operator"},"==="),s(),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
        `),n("span",{class:"token keyword"},"return"),s(),n("span",{class:"token punctuation"},"["),n("span",{class:"token punctuation"},"]"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token punctuation"},"}"),s(`

    `),n("span",{class:"token keyword"},"const"),s(" wordLength "),n("span",{class:"token operator"},"="),s(" words"),n("span",{class:"token punctuation"},"["),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},"]"),n("span",{class:"token punctuation"},"."),s("length"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token keyword"},"const"),s(" wordCount "),n("span",{class:"token operator"},"="),s(" words"),n("span",{class:"token punctuation"},"."),s("length"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token keyword"},"const"),s(" wordMap "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token punctuation"},"{"),n("span",{class:"token punctuation"},"}"),n("span",{class:"token punctuation"},";"),s(`

    `),n("span",{class:"token comment"},"// 初始化词频表"),s(`
    `),n("span",{class:"token keyword"},"for"),s(),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"const"),s(" word "),n("span",{class:"token keyword"},"of"),s(" words"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
        wordMap`),n("span",{class:"token punctuation"},"["),s("word"),n("span",{class:"token punctuation"},"]"),s(),n("span",{class:"token operator"},"="),s(),n("span",{class:"token punctuation"},"("),s("wordMap"),n("span",{class:"token punctuation"},"["),s("word"),n("span",{class:"token punctuation"},"]"),s(),n("span",{class:"token operator"},"||"),s(),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token operator"},"+"),s(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token punctuation"},"}"),s(`

    `),n("span",{class:"token keyword"},"const"),s(" result "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token punctuation"},"["),n("span",{class:"token punctuation"},"]"),n("span",{class:"token punctuation"},";"),s(`

    `),n("span",{class:"token comment"},"// 遍历字符串，尝试每个可能的起始位置"),s(`
    `),n("span",{class:"token keyword"},"for"),s(),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"let"),s(" i "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},";"),s(" i "),n("span",{class:"token operator"},"<"),s(" wordLength"),n("span",{class:"token punctuation"},";"),s(" i"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
        `),n("span",{class:"token keyword"},"let"),s(" left "),n("span",{class:"token operator"},"="),s(" i"),n("span",{class:"token punctuation"},","),s(" right "),n("span",{class:"token operator"},"="),s(" i"),n("span",{class:"token punctuation"},";"),s(`
        `),n("span",{class:"token keyword"},"let"),s(" currentWordMap "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token punctuation"},"{"),n("span",{class:"token punctuation"},"}"),n("span",{class:"token punctuation"},";"),s(`

        `),n("span",{class:"token keyword"},"while"),s(),n("span",{class:"token punctuation"},"("),s("right "),n("span",{class:"token operator"},"+"),s(" wordLength "),n("span",{class:"token operator"},"<="),s(" s"),n("span",{class:"token punctuation"},"."),s("length"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
            `),n("span",{class:"token keyword"},"const"),s(" currentWord "),n("span",{class:"token operator"},"="),s(" s"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"slice"),n("span",{class:"token punctuation"},"("),s("right"),n("span",{class:"token punctuation"},","),s(" right "),n("span",{class:"token operator"},"+"),s(" wordLength"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
            right `),n("span",{class:"token operator"},"+="),s(" wordLength"),n("span",{class:"token punctuation"},";"),s(`

            `),n("span",{class:"token keyword"},"if"),s(),n("span",{class:"token punctuation"},"("),n("span",{class:"token operator"},"!"),n("span",{class:"token punctuation"},"("),s("currentWord "),n("span",{class:"token keyword"},"in"),s(" wordMap"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
                `),n("span",{class:"token comment"},"// 重置词频表和左指针，当前单词不在 words 中"),s(`
                currentWordMap `),n("span",{class:"token operator"},"="),s(),n("span",{class:"token punctuation"},"{"),n("span",{class:"token punctuation"},"}"),n("span",{class:"token punctuation"},";"),s(`
                left `),n("span",{class:"token operator"},"="),s(" right"),n("span",{class:"token punctuation"},";"),s(`
            `),n("span",{class:"token punctuation"},"}"),s(),n("span",{class:"token keyword"},"else"),s(),n("span",{class:"token punctuation"},"{"),s(`
                `),n("span",{class:"token comment"},"// 更新当前词频表"),s(`
                currentWordMap`),n("span",{class:"token punctuation"},"["),s("currentWord"),n("span",{class:"token punctuation"},"]"),s(),n("span",{class:"token operator"},"="),s(),n("span",{class:"token punctuation"},"("),s("currentWordMap"),n("span",{class:"token punctuation"},"["),s("currentWord"),n("span",{class:"token punctuation"},"]"),s(),n("span",{class:"token operator"},"||"),s(),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token operator"},"+"),s(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},";"),s(`

                `),n("span",{class:"token comment"},"// 移动左指针，排除多余的单词"),s(`
                `),n("span",{class:"token keyword"},"while"),s(),n("span",{class:"token punctuation"},"("),s("currentWordMap"),n("span",{class:"token punctuation"},"["),s("currentWord"),n("span",{class:"token punctuation"},"]"),s(),n("span",{class:"token operator"},">"),s(" wordMap"),n("span",{class:"token punctuation"},"["),s("currentWord"),n("span",{class:"token punctuation"},"]"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
                    `),n("span",{class:"token keyword"},"const"),s(" leftWord "),n("span",{class:"token operator"},"="),s(" s"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"slice"),n("span",{class:"token punctuation"},"("),s("left"),n("span",{class:"token punctuation"},","),s(" left "),n("span",{class:"token operator"},"+"),s(" wordLength"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
                    currentWordMap`),n("span",{class:"token punctuation"},"["),s("leftWord"),n("span",{class:"token punctuation"},"]"),n("span",{class:"token operator"},"--"),n("span",{class:"token punctuation"},";"),s(`
                    left `),n("span",{class:"token operator"},"+="),s(" wordLength"),n("span",{class:"token punctuation"},";"),s(`
                `),n("span",{class:"token punctuation"},"}"),s(`

                `),n("span",{class:"token comment"},"// 判断是否找到了一个串联子串"),s(`
                `),n("span",{class:"token keyword"},"if"),s(),n("span",{class:"token punctuation"},"("),s("right "),n("span",{class:"token operator"},"-"),s(" left "),n("span",{class:"token operator"},"==="),s(" wordCount "),n("span",{class:"token operator"},"*"),s(" wordLength"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
                    result`),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"push"),n("span",{class:"token punctuation"},"("),s("left"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
                `),n("span",{class:"token punctuation"},"}"),s(`
            `),n("span",{class:"token punctuation"},"}"),s(`
        `),n("span",{class:"token punctuation"},"}"),s(`
    `),n("span",{class:"token punctuation"},"}"),s(`

    `),n("span",{class:"token keyword"},"return"),s(" result"),n("span",{class:"token punctuation"},";"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),L={id:"最小覆盖子串-难",tabindex:"-1"},B={class:"header-anchor",href:"#最小覆盖子串-难"},C={href:"https://leetcode.cn/problems/minimum-window-substring/",target:"_blank",rel:"noopener noreferrer"},T=o(`<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;
输出：&quot;BANC&quot;
解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#39;A&#39;、&#39;B&#39; 和 &#39;C&#39;。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：s = &quot;a&quot;, t = &quot;a&quot;
输出：&quot;a&quot;
解释：整个字符串 s 是最小覆盖子串。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 3:</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入: s = &quot;a&quot;, t = &quot;aa&quot;
输出: &quot;&quot;
解释: t 中两个字符 &#39;a&#39; 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>提示：</strong></p><ul><li><code>m == s.length</code></li><li><code>n == t.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><div class="hint-container tip"><p class="hint-container-title">解题思路</p><p>本问题要求我们返回字符串 s 中包含字符串 t 的全部字符的最小窗口。我们称包含 t 的全部字母的窗口为「可行」窗口。</p><p>我们可以用滑动窗口的思想解决这个问题。在滑动窗口类型的问题中都会有两个指针，一个用于「延伸」现有窗口的 r 指针，和一个用于「收缩」窗口的 l 指针。在任意时刻，只有一个指针运动，而另一个保持静止。我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。</p><figure><img src="https://raw.githubusercontent.com/GodX-18/picBed/main/76_fig1.gif" alt="fig1" tabindex="0" loading="lazy"><figcaption>fig1</figcaption></figure><p>如何判断当前的窗口包含所有 t 所需的字符呢？我们可以用一个哈希表表示 t 中所有的字符以及它们的个数，用一个哈希表动态维护窗口中所有的字符以及它们的个数，如果这个动态表中包含 t 的哈希表中的所有字符，并且对应的个数都不小于 t 的哈希表中各个字符的个数，那么当前的窗口是「可行」的。</p><p>注意：这里 t 中可能出现重复的字符，所以我们要记录字符的个数。</p><p><strong>具体流程</strong></p><ol><li>初始化变量：设置minLen为s.length + 1，start为s.length，map为一个空对象，missingType为0。其中，minLen表示最小窗口长度，start表示最小窗口的起始位置，map用于记录目标字符串t中各字符的出现次数，missingType表示当前还缺少的字符种类数。</li><li>遍历目标字符串t，统计每个字符的出现次数，并更新map和missingType。</li><li>使用两个指针l和r，表示窗口的左右边界，初始化为0。移动右指针r，扩展窗口，同时更新map中对应字符的出现次数。</li><li>当窗口包含t中所有字符时，进入内循环（missingType == 0）。在内循环中，比较当前窗口长度与minLen的关系，如果更短则更新minLen和start的值。</li><li>移动左指针l，缩小窗口，同时更新map中对应字符的出现次数。如果某个字符的出现次数大于0，表示当前窗口缺少该字符，此时更新missingType。</li><li>重复步骤3到步骤5，直到右指针r到达字符串s的末尾。</li><li>最终，返回最小窗口的子串，如果不存在则返回空字符串。</li></ol><p>该算法的关键点在于通过移动左右指针维护一个滑动窗口，不断更新窗口内字符的出现次数，以找到包含目标字符串t所有字符的最短子串。</p></div><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 函数接收两个字符串 s 和 t，目的是在 s 中找到包含 t 所有字符的最小窗口子串</span>
<span class="token keyword">const</span> <span class="token function-variable function">minWindow</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">,</span> t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> minLen <span class="token operator">=</span> s<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 最小窗口长度的初始值为 s 长度 + 1</span>
    <span class="token keyword">let</span> start <span class="token operator">=</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>      <span class="token comment">// 最小窗口的起始位置初始值为 s 长度</span>
    <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>              <span class="token comment">// 存储目标字符和对应的缺失个数的映射</span>
    <span class="token keyword">let</span> missingType <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment">// 当前缺失的字符种类数</span>

    <span class="token comment">// 遍历字符串 t，初始化目标字符计数映射</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> c <span class="token keyword">of</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            missingType<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 需要找齐的种类数 +1</span>
            map<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            map<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">let</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 左右指针初始化</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> rightChar <span class="token operator">=</span> s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 获取右指针指向的新字符</span>

        <span class="token comment">// 如果新字符是目标字符，将其对应的缺失个数减一</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">[</span>rightChar<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> map<span class="token punctuation">[</span>rightChar<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>

        <span class="token comment">// 如果新字符的缺失个数变为 0，缺失的种类数减一</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">[</span>rightChar<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> missingType<span class="token operator">--</span><span class="token punctuation">;</span>

        <span class="token comment">// 当前窗口包含所有字符的前提下，尽量收缩窗口</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>missingType <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果窗口宽度比 minLen 小，更新 minLen 和最小窗口的起点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> minLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                minLen <span class="token operator">=</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                start <span class="token operator">=</span> l<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">let</span> leftChar <span class="token operator">=</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 左指针右移，左指针指向的字符要被丢弃</span>

            <span class="token comment">// 被舍弃的是目标字符，将其对应的缺失个数加一</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">[</span>leftChar<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> map<span class="token punctuation">[</span>leftChar<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>

            <span class="token comment">// 如果被舍弃的字符的缺失个数新变为正数，缺失的种类数加一</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">[</span>leftChar<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> missingType<span class="token operator">++</span><span class="token punctuation">;</span>

            l<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 左指针右移，收缩窗口</span>
        <span class="token punctuation">}</span>
        r<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 右指针右移，扩张窗口</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果最小窗口的起点仍然是 s 长度，说明没有找到符合条件的窗口，返回空字符串；否则，返回最小窗口子串</span>
    <span class="token keyword">return</span> start <span class="token operator">==</span> s<span class="token punctuation">.</span>length <span class="token operator">?</span> <span class="token string">&quot;&quot;</span> <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> start <span class="token operator">+</span> minLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,13);function M(W,S){const t=l("ExternalLinkIcon"),i=l("CodeTabs");return r(),d("div",null,[n("h2",m,[n("a",v,[n("span",null,[n("a",b,[s("长度最小的子数组(中)"),a(t)])])])]),g,n("h2",h,[n("a",w,[n("span",null,[n("a",f,[s("无重复字符的最长子串(中)"),a(t)])])])]),y,n("h2",q,[n("a",x,[n("span",null,[n("a",_,[s("串联所有单词的子串(难)"),a(t)])])])]),E,a(i,{id:"264",data:[{id:"self"},{id:"AI"}],"tab-id":"shell"},{title0:e(({value:c,isActive:p})=>[s("self")]),title1:e(({value:c,isActive:p})=>[s("AI")]),tab0:e(({value:c,isActive:p})=>[A]),tab1:e(({value:c,isActive:p})=>[j]),_:1}),n("h2",L,[n("a",B,[n("span",null,[n("a",C,[s("最小覆盖子串(难)"),a(t)])])])]),T])}const G=u(k,[["render",M],["__file","案例.html.vue"]]),O=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E6%A1%88%E4%BE%8B.html","title":"案例","lang":"zh-CN","frontmatter":{"title":"案例","date":"2024-01-11T00:00:00.000Z","order":2,"category":["算法"],"tag":["滑动窗口"],"description":"长度最小的子数组(中) 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度**。**如果不存在符合条件的子数组，返回 0 。 示例 1： 示例 2： 示例 3： 提示： 1 <=...","head":[["meta",{"property":"og:url","content":"https://godx-18.github.io/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E6%A1%88%E4%BE%8B.html"}],["meta",{"property":"og:site_name","content":"烜"}],["meta",{"property":"og:title","content":"案例"}],["meta",{"property":"og:description","content":"长度最小的子数组(中) 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度**。**如果不存在符合条件的子数组，返回 0 。 示例 1： 示例 2： 示例 3： 提示： 1 <=..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/GodX-18/picBed/main/76_fig1.gif"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-20T08:17:41.000Z"}],["meta",{"property":"article:author","content":"GodX"}],["meta",{"property":"article:tag","content":"滑动窗口"}],["meta",{"property":"article:published_time","content":"2024-01-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-01-20T08:17:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"案例\\",\\"image\\":[\\"https://raw.githubusercontent.com/GodX-18/picBed/main/76_fig1.gif\\"],\\"datePublished\\":\\"2024-01-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-01-20T08:17:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"GodX\\",\\"url\\":\\"https://github.com/GodX-18\\"}]}"]]},"headers":[{"level":2,"title":"长度最小的子数组(中)","slug":"长度最小的子数组-中","link":"#长度最小的子数组-中","children":[]},{"level":2,"title":"无重复字符的最长子串(中)","slug":"无重复字符的最长子串-中","link":"#无重复字符的最长子串-中","children":[]},{"level":2,"title":"串联所有单词的子串(难)","slug":"串联所有单词的子串-难","link":"#串联所有单词的子串-难","children":[]},{"level":2,"title":"最小覆盖子串(难)","slug":"最小覆盖子串-难","link":"#最小覆盖子串-难","children":[]}],"git":{"createdTime":1705738661000,"updatedTime":1705738661000,"contributors":[{"name":"GodX","email":"1046529973@qq.com","commits":1}]},"readingTime":{"minutes":13.12,"words":3935},"filePathRelative":"算法/滑动窗口/案例.md","localizedDate":"2024年1月11日","excerpt":"<h2><a class=\\"header-anchor\\" href=\\"#长度最小的子数组-中\\"><span></span></a><a href=\\"https://leetcode.cn/problems/minimum-size-subarray-sum/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">长度最小的子数组(中)</a></h2>\\n<p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>\\n<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度**。**如果不存在符合条件的子数组，返回 <code>0</code> 。</p>","autoDesc":true}');export{G as comp,O as data};
