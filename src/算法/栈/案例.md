---
title: 案例
date: 2024-02-10
order: 1
category:
  - 算法
tag:
  - 区间
---

## [有效的括号(简)](https://leetcode.cn/problems/valid-parentheses/)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

```js
输入：s = "()"
输出：true
```

**示例 2：**

```js
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```js
输入：s = "(]"
输出：false
```


:::tip 提示

* 1 <= s.length <= 104
* s 仅由括号 '()[]{}' 组成

:::

:::info 解题思路

* 有效括号字符串的长度，一定是偶数！
* 右括号前面，必须是相对应的左括号，才能抵消！
* 右括号前面，不是对应的左括号，那么该字符串，一定不是有效的括号！

:::

```js
var isValid = function (s) {
    // 如果字符串长度为奇数，直接返回false
    if(s.length % 2) return false;
    // 创建一个栈
    const stack = []
    // 创建一个映射表，用来存储括号的对应关系
    const map = {
        "(": ")",
        "{": "}",
        "[": "]"
    };
    // 遍历输入字符串中的每个字符
    for (const x of s) {
        // 如果字符是左括号，则将其推入栈中
        if (x in map) {
            stack.push(x);
            continue;
        };
        // 如果字符是右括号，则与栈顶元素进行匹配
        // 如果匹配失败，说明不是有效的括号序列，直接返回false
        if (map[stack.pop()] !== x) return false;
    }
    // 最后栈为空，则说明是有效的括号序列，返回true，否则返回false
    return !stack.length;
};
```

## [简化路径(中)](https://leetcode.cn/problems/simplify-path/)

给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点 （`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，`'//'`）都被视为单个斜杠 `'/'` 。 对于此问题，任何其他格式的点（例如，`'...'`）均被视为文件/目录名称。

请注意，返回的 **规范路径** 必须遵循下述格式：

- 始终以斜杠 `'/'` 开头。
- 两个目录名之间必须只有一个斜杠 `'/'` 。
- 最后一个目录名（如果存在）**不能** 以 `'/'` 结尾。
- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'` 或 `'..'`）。

返回简化后得到的 **规范路径** 。

**示例 1：**

```
输入：path = "/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。 
```

**示例 2：**

```
输入：path = "/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。
```

**示例 3：**

```
输入：path = "/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
```

**示例 4：**

```
输入：path = "/a/./b/../../c/"
输出："/c"
```

**提示：**

- `1 <= path.length <= 3000`
- `path` 由英文字母，数字，`'.'`，`'/'` 或 `'_'` 组成。
- `path` 是一个有效的 Unix 风格绝对路径。

:::tip 解题思路

我们首先将给定的字符串 path 根据/ 分割成一个由若干字符串组成的列表，记为 names。根据题目中规定的「规范路径的下述格式」，names 中包含的字符串只能为以下几种：

空字符串。例如当出现多个连续的 /，就会分割出空字符串；

一个点 .；

两个点 ..；

只包含英文字母、数字或 _ 的目录名。

对于「空字符串」以及「一个点」，我们实际上无需对它们进行处理，因为「空字符串」没有任何含义，而「一个点」表示当前目录本身，我们无需切换目录。

对于「两个点」或者「目录名」，我们则可以用一个栈来维护路径中的每一个目录名。当我们遇到「两个点」时，需要将目录切换到上一级，因此只要栈不为空，我们就弹出栈顶的目录。当我们遇到「目录名」时，就把它放入栈。

这样一来，我们只需要遍历 names 中的每个字符串并进行上述操作即可。在所有的操作完成后，我们将从栈底到栈顶的字符串用 / 进行连接，再在最前面加上 / 表示根目录，就可以得到简化后的规范路径。

:::

```js
/**
 * @param {string} path 文件路径
 * @return {string} 简化后的文件路径
 */
var simplifyPath = function(path) {
    // 将路径按照 '/' 分割成数组
    const arr = path.split('/');
    // 使用栈来存储路径
    const stack = []
    // 遍历路径数组
    for(let i of arr) {
        // 如果当前路径为 '..'，表示返回上级目录
        if(i === '..') {
            // 如果栈不为空，表示还有父级目录，弹出栈顶元素
            if(stack.length) {
                stack.pop()
            }
        } else if(i.length && i !== '.') {
            // 如果路径不为空且不为 '.'，表示当前路径有效，入栈
            stack.push(i)
        }
    }
    // 将栈中的路径元素用 '/' 连接成字符串，并返回
    return '/' + stack.join('/')
};
```

## [逆波兰表达式求值(中)](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。

**示例 1：**

```
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

**示例 2：**

```
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```

**示例 3：**

```
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

**提示：**

- `1 <= tokens.length <= 104`
- `tokens[i]` 是一个算符（`"+"`、`"-"`、`"*"` 或 `"/"`），或是在范围 `[-200, 200]` 内的一个整数

**逆波兰表达式：**

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

- 平常使用的算式则是一种中缀表达式，如 `( 1 + 2 ) * ( 3 + 4 )` 。
- 该算式的逆波兰表达式写法为 `( ( 1 2 + ) ( 3 4 + ) * )` 。

逆波兰表达式主要有以下两个优点：

- 去掉括号后表达式无歧义，上式即便写成 `1 2 + 3 4 + * `也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

:::tip 解题思路

1. 初始化一个空堆栈 `stack` 用来存储操作数。
2. 遍历给定的逆波兰表达式 `tokens`。
3. 对于每个token：
   - 如果token是一个数字，则将其转换为整数并将其压入堆栈。
   - 如果token是一个运算符，则从堆栈中弹出两个操作数，执行相应的运算后将结果压入堆栈。
4. 最后，堆栈中剩下的元素即为计算结果，返回堆栈顶部的元素（堆栈中应该只剩下一个元素）。

这个函数通过模拟逆波兰表达式的计算过程，利用堆栈数据结构实现了简单而有效的计算方法。

![150.逆波兰表达式求值](https://raw.githubusercontent.com/GodX-18/picBed/main/1614612916-nfKkEF-e6c9d24ely1go4tsist8wg20cc0age81.gif)

相信

:::

```js
function evalRPN(tokens) {
    let stack = [];
    for (let token of tokens) {
        if (!isNaN(parseInt(token))) {
            stack.push(parseInt(token));
        } else {
            let num2 = stack.pop();
            let num1 = stack.pop();
            switch (token) {
                case "+":
                    stack.push(num1 + num2);
                    break;
                case "-":
                    stack.push(num1 - num2);
                    break;
                case "*":
                    stack.push(num1 * num2);
                    break;
                case "/":
                    stack.push(Math.trunc(num1 / num2));
                    break;
            }
        }
    }
    return stack[0];
}
```

## [基本计算器(难)](https://leetcode.cn/problems/basic-calculator/)

给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。

注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 `eval()` 。

**示例 1：**

```
输入：s = "1 + 1"
输出：2
```

**示例 2：**

```
输入：s = " 2-1 + 2 "
输出：3
```

**示例 3：**

```
输入：s = "(1+(4+5+2)-3)+(6+8)"
输出：23
```

**提示：**

- `1 <= s.length <= 3 * 105`
- `s` 由数字、`'+'`、`'-'`、`'('`、`')'`、和 `' '` 组成
- `s` 表示一个有效的表达式
- '+' 不能用作一元运算(例如， "+1" 和 `"+(2 + 3)"` 无效)
- '-' 可以用作一元运算(即 "-1" 和 `"-(2 + 3)"` 是有效的)
- 输入中不存在两个连续的操作符
- 每个数字和运行的计算将适合于一个有符号的 32位 整数

:::tip 解题思路

1. 初始化结果`ans`为0，数字栈`num_stack`为空，运算符栈`op_stack`为空，符号`sign`为1（正号）。
2. 遍历输入字符串 `s`：
   - 忽略空格。
   - 遇到加号或减号时，更新`sign`。
   - 遇到数字时，读取完整的数字，并将其乘以`sign`后加到`ans`上。
   - 遇到左括号时，将当前`ans`和`sign`压入各自的栈，并重置`ans`和`sign`。
   - 遇到右括号时，从栈中弹出一个数字和一个运算符，并计算括号内的表达式结果，加到`ans`上。
3. 返回最终结果`ans`。

:::

```js
var calculate = function (s) {
    let ans = 0; // 初始化结果为0
    let num_stack = []; // 用于存储数字的栈
    let op_stack = []; // 用于存储运算符的栈
    let sign = 1; // 记录当前数字的符号，默认为正号

    for (let i = 0; i < s.length; i++) { // 遍历输入字符串
        if (s[i] == ' ') continue; // 如果当前字符为空格，则跳过本次循环

        if (s[i] == '+' || s[i] == '-') { // 如果当前字符为加号或减号
            sign = s[i] == '+' ? 1 : -1; // 更新符号
        } else if (s[i] >= '0' && s[i] <= '9') { // 如果当前字符为数字
            let num = parseInt(s[i]); // 将当前字符转换为数字
            while (i < s.length - 1 && s[i + 1] >= '0' && s[i + 1] <= '9') { // 循环读取多位数字
                num = num * 10 + parseInt(s[++i]); // 合并多位数字
            }
            ans += sign * num; // 将当前数字加入结果中，考虑其符号
        } else if (s[i] == '(') { // 如果当前字符为左括号
            num_stack.push(ans); // 将当前结果压入数字栈
            op_stack.push(sign); // 将当前符号压入运算符栈
            ans = 0; // 重置结果
            sign = 1; // 重置符号
        } else { // 如果当前字符为右括号
            ans = num_stack.pop() + ans * op_stack.pop(); // 计算括号内的结果
        }
    }
    return ans; // 返回最终结果
};

```

