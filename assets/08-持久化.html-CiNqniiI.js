import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as s,o as t,c as i,b as e,e as d,d as o,a as l}from"./app-oXp7PBbS.js";const c={},p=l(`<p>Redis 的强劲性能很大程度上是由于其将所有数据都存储在内存中，然而当 Redis 重启或宕机后，所有存储在内存中的数据就会丢失。在一些情况下，我们会希望 Redis 在重启后能够保证数据不丢失。</p><p>这时我们希望 Redis 能将数据从内存中以某种形式同步到硬盘中，使得重启后可以根据硬盘中的记录恢复数据。这一过程就是持久化。</p><p>Redis 提供了两种持久化方案：</p><ul><li>RDB 持久化，根据指定的规则“定时”将内存中的数据存储在硬盘上，在重启之后读取硬盘上的 <code>.rdb</code> 快照文件将数据恢复到内存中。</li><li>AOF 持久化：AOF 持久化记录服务器执行的所有写操作命令形成 <code>.aof</code> 日志文件保存到硬盘中，并在服务器启动时，通过重新执行这些命令来还原数据集。</li></ul><h2 id="rdb-持久化" tabindex="-1"><a class="header-anchor" href="#rdb-持久化"><span>RDB 持久化</span></a></h2><p>RDB 方式的持久化是通过快照完成的，当符合一定条件时 Redis 会自动将内存中的所有数据生成一份副本并存储在硬盘上，这个过程即为“快照”。</p><p>Redis 允许用户自定义快照条件，当符合快照条件时，Redis 会自动执行快照操作。进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：时间窗口 M 和改动的键的个数 N。每当时间 M 内被更改的键的个数大于 N 时，即符合自动快照条件。</p><p>RDB 持久化相关配置规则如下：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>save <span class="token number">900</span> <span class="token number">1</span> <span class="token comment"># 每 900 秒至少有 1 个 key 变化了，则写入快照</span>
save <span class="token number">300</span> <span class="token number">10</span> <span class="token comment"># 每 300 秒至少有 10 个 key 变化了，则写入快照</span>
save <span class="token number">60</span> <span class="token number">10000</span> <span class="token comment"># 每 60 秒至少有 10000 个 key 变化了，则写入快照</span>

dbfilename dump.rdb <span class="token comment"># 快照保存的文件名称</span>

<span class="token function">dir</span> ./ <span class="token comment"># 快照文件保存路径</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>RDB 快照的运行方式是异步进行的，在保存快照期间依然能够提供客户端请求。</p><figure><img src="https://raw.githubusercontent.com/GodX-18/picBed/main/image-20231017094820225.png" alt="image-20231017094820225" tabindex="0" loading="lazy"><figcaption>image-20231017094820225</figcaption></figure><ol><li>Redis 调用 <code>fork()</code> 创建一个子进程</li><li>使用子进程将数据集写入到一个临时 RDB 文件中</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件</li></ol><h2 id="aof-持久化" tabindex="-1"><a class="header-anchor" href="#aof-持久化"><span>AOF 持久化</span></a></h2><p>快照功能并不是非常持久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。</p><p>尽管对于某些程序来说， 数据的持久性并不是最重要的考虑因素， 但是对于那些追求完全持久化（full durability）的程序来说， 快照功能就不太适用了。</p><p>从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p><p>AOF 可以将 Redis 执行的每一条写命令操作日志存储到硬盘文件中，这一过程显然会降低 Redis 的性能，但是大部分情况下这个影响是可以接受的，另外使用较快硬盘可以提供 AOF 性能。</p><p>AOF 机制对于日志的写入操作采用的是 <code>append</code> 模式，就是追加模式，因此在写入过程中如果出现宕机问题，也不会破坏已经写入的日志数据。</p><p>默认情况下，Redis 没有开启 AOF 方式的持久化，可以通过 <code>appendonly</code> 参数启用：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>appendonly <span class="token function">yes</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>AOF 文件的保存位置和 RDB 文件的位置相同，都是 <code>dir</code> 参数设置的。默认的文件名是 <code>appendonly.aof</code>，可以通过 <code>appendfilename</code> 来修改：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># AOF 文件和 RDB 文件保存目录是一样的</span>
<span class="token function">dir</span> ./

<span class="token comment"># 同步的文件名称</span>
appendfilename <span class="token string">&quot;appendonly.aof&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AOF 有三种同步策略：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 每修改同步，每一次发送数据变化都会被立即同步到磁盘中，效率比较低，但是数据最安全</span>
appendfsync always

<span class="token comment"># 默认值，每秒同步，异步完成，同步效率非常高，缺点是一旦系统出现宕机，这1秒之内操作的数据就会丢失</span>
appendfsync everysec

<span class="token comment"># 不同步</span>
appendfsync no
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般情况下使用默认值 everysec 就足够了，既兼顾了性能又保证了安全。</p><h2 id="rdb-vs-aof" tabindex="-1"><a class="header-anchor" href="#rdb-vs-aof"><span>RDB vs AOF</span></a></h2><table><thead><tr><th>持久化方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>RDB</td><td>文件小异步备份，性能好恢复大数据集速度比 AOF 快</td><td>数据安全性低，容易丢失数据数据量比较大时备份速度慢</td></tr><tr><td>AOF</td><td>数据安全性高有利于开发分析</td><td>相同数据集比 RDB 文件大根据所使用的 fsync 策略，AOF 速度可能会慢于 RDB</td></tr></tbody></table><p>一般来说， 如果想达到足以媲美关系型数据库的安全性， 你应该同时使用两种持久化功能。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接"><span>参考链接</span></a></h2>`,31),r={href:"http://doc.redisfans.com/topic/persistence.html",target:"_blank",rel:"noopener noreferrer"};function m(u,h){const n=s("ExternalLinkIcon");return t(),i("div",null,[p,e("ul",null,[e("li",null,[e("a",r,[d("http://doc.redisfans.com/topic/persistence.html"),o(n)])])])])}const g=a(c,[["render",m],["__file","08-持久化.html.vue"]]),R=JSON.parse('{"path":"/%E5%A4%A7%E5%89%8D%E7%AB%AF/Nodejs%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/Redis/08-%E6%8C%81%E4%B9%85%E5%8C%96.html","title":"持久化","lang":"zh-CN","frontmatter":{"title":"持久化","order":8,"category":["前端"],"tag":["nodejs","Redis"],"description":"Redis 的强劲性能很大程度上是由于其将所有数据都存储在内存中，然而当 Redis 重启或宕机后，所有存储在内存中的数据就会丢失。在一些情况下，我们会希望 Redis 在重启后能够保证数据不丢失。 这时我们希望 Redis 能将数据从内存中以某种形式同步到硬盘中，使得重启后可以根据硬盘中的记录恢复数据。这一过程就是持久化。 Redis 提供了两种持久...","head":[["meta",{"property":"og:url","content":"https://godx-18.github.io/%E5%A4%A7%E5%89%8D%E7%AB%AF/Nodejs%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91/Redis/08-%E6%8C%81%E4%B9%85%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"烜"}],["meta",{"property":"og:title","content":"持久化"}],["meta",{"property":"og:description","content":"Redis 的强劲性能很大程度上是由于其将所有数据都存储在内存中，然而当 Redis 重启或宕机后，所有存储在内存中的数据就会丢失。在一些情况下，我们会希望 Redis 在重启后能够保证数据不丢失。 这时我们希望 Redis 能将数据从内存中以某种形式同步到硬盘中，使得重启后可以根据硬盘中的记录恢复数据。这一过程就是持久化。 Redis 提供了两种持久..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/GodX-18/picBed/main/image-20231017094820225.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-20T06:54:21.000Z"}],["meta",{"property":"article:author","content":"GodX"}],["meta",{"property":"article:tag","content":"nodejs"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:modified_time","content":"2024-03-20T06:54:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"持久化\\",\\"image\\":[\\"https://raw.githubusercontent.com/GodX-18/picBed/main/image-20231017094820225.png\\"],\\"dateModified\\":\\"2024-03-20T06:54:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"GodX\\",\\"url\\":\\"https://github.com/GodX-18\\"}]}"]]},"headers":[{"level":2,"title":"RDB 持久化","slug":"rdb-持久化","link":"#rdb-持久化","children":[]},{"level":2,"title":"AOF 持久化","slug":"aof-持久化","link":"#aof-持久化","children":[]},{"level":2,"title":"RDB vs AOF","slug":"rdb-vs-aof","link":"#rdb-vs-aof","children":[]},{"level":2,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"git":{"createdTime":1700614687000,"updatedTime":1710917661000,"contributors":[{"name":"GodX","email":"1046529973@qq.com","commits":2}]},"readingTime":{"minutes":4.56,"words":1368},"filePathRelative":"大前端/Nodejs全栈开发/Redis/08-持久化.md","localizedDate":"2023年11月22日","excerpt":"<p>Redis 的强劲性能很大程度上是由于其将所有数据都存储在内存中，然而当 Redis 重启或宕机后，所有存储在内存中的数据就会丢失。在一些情况下，我们会希望 Redis 在重启后能够保证数据不丢失。</p>\\n<p>这时我们希望 Redis 能将数据从内存中以某种形式同步到硬盘中，使得重启后可以根据硬盘中的记录恢复数据。这一过程就是持久化。</p>\\n<p>Redis 提供了两种持久化方案：</p>\\n<ul>\\n<li>RDB 持久化，根据指定的规则“定时”将内存中的数据存储在硬盘上，在重启之后读取硬盘上的 <code>.rdb</code> 快照文件将数据恢复到内存中。</li>\\n<li>AOF 持久化：AOF 持久化记录服务器执行的所有写操作命令形成 <code>.aof</code> 日志文件保存到硬盘中，并在服务器启动时，通过重新执行这些命令来还原数据集。</li>\\n</ul>","autoDesc":true}');export{g as comp,R as data};
