import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,a as t}from"./app-oXp7PBbS.js";const e={},p=t(`<h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h2><p>深度优先遍历（Depth-First Search, DFS）和广度优先遍历（Breadth-First Search, BFS）是两种常见的遍历或搜索树或图的算法。</p><h3 id="深度优先遍历-dfs" tabindex="-1"><a class="header-anchor" href="#深度优先遍历-dfs"><span>深度优先遍历（DFS）</span></a></h3><p>深度优先遍历首先深入到可能的最深层次，然后回溯到之前的节点以探索未访问的分支。在二叉树中，DFS可以通过递归或栈来实现。DFS有三种变体：</p><ol><li>前序遍历（Pre-order）：先访问根节点，然后遍历左子树，最后遍历右子树。</li><li>中序遍历（In-order）：先遍历左子树，然后访问根节点，最后遍历右子树。</li><li>后序遍历（Post-order）：先遍历左子树，然后遍历右子树，最后访问根节点。</li></ol><h3 id="广度优先遍历-bfs" tabindex="-1"><a class="header-anchor" href="#广度优先遍历-bfs"><span>广度优先遍历（BFS）</span></a></h3><p>广度优先遍历从根节点开始，逐层访问节点。在二叉树中，BFS通常使用队列来实现。BFS首先访问根节点，然后访问根节点的所有直接子节点，接着访问这些子节点的子节点，依此类推，直到所有节点都被访问。</p><h3 id="二叉树的dfs和bfs示例" tabindex="-1"><a class="header-anchor" href="#二叉树的dfs和bfs示例"><span>二叉树的DFS和BFS示例</span></a></h3><p>假设我们有以下二叉树：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>    A
   / \\
  B   C
 / \\   \\
D   E   F
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="dfs-前序遍历-的结果-a-b-d-e-c-f" tabindex="-1"><a class="header-anchor" href="#dfs-前序遍历-的结果-a-b-d-e-c-f"><span>DFS（前序遍历）的结果：A B D E C F</span></a></h4><h4 id="dfs-中序遍历-的结果-d-b-e-a-c-f" tabindex="-1"><a class="header-anchor" href="#dfs-中序遍历-的结果-d-b-e-a-c-f"><span>DFS（中序遍历）的结果：D B E A C F</span></a></h4><h4 id="dfs-后序遍历-的结果-d-e-b-f-c-a" tabindex="-1"><a class="header-anchor" href="#dfs-后序遍历-的结果-d-e-b-f-c-a"><span>DFS（后序遍历）的结果：D E B F C A</span></a></h4><h4 id="bfs的结果-a-b-c-d-e-f" tabindex="-1"><a class="header-anchor" href="#bfs的结果-a-b-c-d-e-f"><span>BFS的结果：A B C D E F</span></a></h4><p>在实际应用中，DFS和BFS可以根据问题的不同而有不同的用途。例如，DFS通常用于求解路径问题、拓扑排序和连通性问题，而BFS通常用于寻找最短路径、迷宫问题和最近的邻居搜索。</p><h3 id="bfs-不是层次遍历" tabindex="-1"><a class="header-anchor" href="#bfs-不是层次遍历"><span>BFS 不是层次遍历</span></a></h3><p>而 BFS 适合求最短距离，这个和层次遍历是不一样的，很多人搞混。这里强调一下，层次遍历和 BFS 是<strong>完全不一样</strong>的东西。</p><p>层次遍历就是一层层遍历树，按照树的层次顺序进行访问。</p><p><strong>BFS 的核心在于求最短问题时候可以提前终止，这才是它的核心价值，层次遍历是一种不需要提前终止的 BFS 的副产物</strong>。这个提前终止不同于 DFS 的剪枝的提前终止，而是找到最近目标的提前终止。比如我要找距离最近的目标节点，BFS 找到目标节点就可以直接返回。而 DFS 要穷举所有可能才能找到最近的，这才是 BFS 的核心价值。实际上，我们也可以使用 DFS 实现层次遍历的效果，借助于递归，代码甚至会更简单。</p><h2 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现"><span>代码实现</span></a></h2><p>在JavaScript中，我们可以使用递归或迭代的方式来编写二叉树的前序、中序和后序遍历算法。下面我将分别展示这三种遍历方式的递归和迭代实现。<br> 首先，我们需要定义一个二叉树的节点类：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，我们可以实现遍历算法：</p><h3 id="前序遍历" tabindex="-1"><a class="header-anchor" href="#前序遍历"><span>前序遍历</span></a></h3><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问根节点</span>
        <span class="token function">traverse</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 遍历左子树</span>
        <span class="token function">traverse</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 遍历右子树</span>
    <span class="token punctuation">}</span>
    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="中序遍历" tabindex="-1"><a class="header-anchor" href="#中序遍历"><span>中序遍历</span></a></h3><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">traverse</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 遍历左子树</span>
        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问根节点</span>
        <span class="token function">traverse</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 遍历右子树</span>
    <span class="token punctuation">}</span>
    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="后序遍历" tabindex="-1"><a class="header-anchor" href="#后序遍历"><span>后序遍历</span></a></h3><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">traverse</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 遍历左子树</span>
        <span class="token function">traverse</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 遍历右子树</span>
        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问根节点</span>
    <span class="token punctuation">}</span>
    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="迭代实现" tabindex="-1"><a class="header-anchor" href="#迭代实现"><span>迭代实现</span></a></h2><p>双色标记法来统一前中后序遍历，下面是中序遍历其他的以此类推。</p><h3 id="中序遍历-1" tabindex="-1"><a class="header-anchor" href="#中序遍历-1"><span>中序遍历</span></a></h3><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">inorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token constant">WHITE</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">GRAY</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 定义两种颜色，WHITE表示未访问，GRAY表示已访问</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储遍历结果</span>
    <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token constant">WHITE</span><span class="token punctuation">,</span> root<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 初始化栈，推入根节点和颜色标记</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token punctuation">[</span>color<span class="token punctuation">,</span> node<span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 弹出栈顶元素和颜色标记</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 如果节点为空，则继续下一次循环</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">===</span> <span class="token constant">WHITE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果节点颜色为WHITE，表示第一次访问</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token constant">WHITE</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先推入右子节点（WHITE）</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token constant">GRAY</span><span class="token punctuation">,</span> node<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 推入当前节点（GRAY）</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token constant">WHITE</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 再推入左子节点（WHITE）</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果节点颜色为GRAY，表示第二次访问</span>
            res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将节点值加入结果数组</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span> <span class="token comment">// 返回遍历结果</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="层次遍历" tabindex="-1"><a class="header-anchor" href="#层次遍历"><span>层次遍历</span></a></h2><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>

    <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 初始化队列，将根节点入队</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> level <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储当前层的节点值</span>
        <span class="token keyword">let</span> levelSize <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 当前层的节点数量</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> levelSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 出队当前节点</span>
            level<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将节点值加入当前层的结果数组</span>

            <span class="token comment">// 将非空的左子节点和右子节点入队</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将当前层的结果数组加入最终结果</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个实现中，我们使用了一个数组<code>queue</code>来模拟队列。</p><ul><li>首先，我们将根节点入队。</li><li>然后，我们进入一个循环，每次循环中我们处理当前层的所有节点。 <ul><li>我们使用一个额外的数组<code>level</code>来存储当前层的节点值，并使用<code>levelSize</code>来记录当前层的节点数量。</li><li>在循环中，我们逐个出队节点，并将它们的值加入<code>level</code>数组，同时将它们的非空子节点入队。</li><li>当当前层的所有节点都被处理完后，我们将<code>level</code>数组加入最终结果<code>result</code>中。</li></ul></li><li>循环继续，直到队列为空，这时所有层的节点都已经被遍历完毕。</li></ul>`,37),o=[p];function c(l,i){return s(),a("div",null,o)}const d=n(e,[["render",c],["__file","概述.html.vue"]]),k=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95/%E6%A0%91/%E6%A6%82%E8%BF%B0.html","title":"概述","lang":"zh-CN","frontmatter":{"title":"概述","date":"2024-03-18T00:00:00.000Z","order":1,"category":["算法"],"tag":["案例"],"description":"基本概念 深度优先遍历（Depth-First Search, DFS）和广度优先遍历（Breadth-First Search, BFS）是两种常见的遍历或搜索树或图的算法。 深度优先遍历（DFS） 深度优先遍历首先深入到可能的最深层次，然后回溯到之前的节点以探索未访问的分支。在二叉树中，DFS可以通过递归或栈来实现。DFS有三种变体： 前序遍历（P...","head":[["meta",{"property":"og:url","content":"https://godx-18.github.io/%E7%AE%97%E6%B3%95/%E6%A0%91/%E6%A6%82%E8%BF%B0.html"}],["meta",{"property":"og:site_name","content":"烜"}],["meta",{"property":"og:title","content":"概述"}],["meta",{"property":"og:description","content":"基本概念 深度优先遍历（Depth-First Search, DFS）和广度优先遍历（Breadth-First Search, BFS）是两种常见的遍历或搜索树或图的算法。 深度优先遍历（DFS） 深度优先遍历首先深入到可能的最深层次，然后回溯到之前的节点以探索未访问的分支。在二叉树中，DFS可以通过递归或栈来实现。DFS有三种变体： 前序遍历（P..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-19T06:54:55.000Z"}],["meta",{"property":"article:author","content":"GodX"}],["meta",{"property":"article:tag","content":"案例"}],["meta",{"property":"article:published_time","content":"2024-03-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-19T06:54:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"概述\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-19T06:54:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"GodX\\",\\"url\\":\\"https://github.com/GodX-18\\"}]}"]]},"headers":[{"level":2,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[{"level":3,"title":"深度优先遍历（DFS）","slug":"深度优先遍历-dfs","link":"#深度优先遍历-dfs","children":[]},{"level":3,"title":"广度优先遍历（BFS）","slug":"广度优先遍历-bfs","link":"#广度优先遍历-bfs","children":[]},{"level":3,"title":"二叉树的DFS和BFS示例","slug":"二叉树的dfs和bfs示例","link":"#二叉树的dfs和bfs示例","children":[]},{"level":3,"title":"BFS 不是层次遍历","slug":"bfs-不是层次遍历","link":"#bfs-不是层次遍历","children":[]}]},{"level":2,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[{"level":3,"title":"前序遍历","slug":"前序遍历","link":"#前序遍历","children":[]},{"level":3,"title":"中序遍历","slug":"中序遍历","link":"#中序遍历","children":[]},{"level":3,"title":"后序遍历","slug":"后序遍历","link":"#后序遍历","children":[]}]},{"level":2,"title":"迭代实现","slug":"迭代实现","link":"#迭代实现","children":[{"level":3,"title":"中序遍历","slug":"中序遍历-1","link":"#中序遍历-1","children":[]}]},{"level":2,"title":"层次遍历","slug":"层次遍历","link":"#层次遍历","children":[]}],"git":{"createdTime":1710740871000,"updatedTime":1718780095000,"contributors":[{"name":"GodX","email":"1046529973@qq.com","commits":4}]},"readingTime":{"minutes":4.9,"words":1470},"filePathRelative":"算法/树/概述.md","localizedDate":"2024年3月18日","excerpt":"<h2>基本概念</h2>\\n<p>深度优先遍历（Depth-First Search, DFS）和广度优先遍历（Breadth-First Search, BFS）是两种常见的遍历或搜索树或图的算法。</p>\\n<h3>深度优先遍历（DFS）</h3>\\n<p>深度优先遍历首先深入到可能的最深层次，然后回溯到之前的节点以探索未访问的分支。在二叉树中，DFS可以通过递归或栈来实现。DFS有三种变体：</p>\\n<ol>\\n<li>前序遍历（Pre-order）：先访问根节点，然后遍历左子树，最后遍历右子树。</li>\\n<li>中序遍历（In-order）：先遍历左子树，然后访问根节点，最后遍历右子树。</li>\\n<li>后序遍历（Post-order）：先遍历左子树，然后遍历右子树，最后访问根节点。</li>\\n</ol>","autoDesc":true}');export{d as comp,k as data};
