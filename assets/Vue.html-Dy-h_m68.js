import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o,c,b as a,e,d as t,a as n}from"./app-oXp7PBbS.js";const p={},d=n('<h2 id="vue-的设计模式" tabindex="-1"><a class="header-anchor" href="#vue-的设计模式"><span>Vue 的设计模式</span></a></h2><h3 id="介绍一下-mvvm-模式和-mvc-模式有什么区别" tabindex="-1"><a class="header-anchor" href="#介绍一下-mvvm-模式和-mvc-模式有什么区别"><span>介绍一下 MVVM 模式和 MVC 模式有什么区别？</span></a></h3><p>MVVM 模式是一种软件架构设计模式，它将应用程序分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。模型负责处理数据和业务逻辑，视图负责显示用户界面，视图模型负责连接视图和模型，并实现数据绑定和命令模式。MVVM 模式的目的是实现视图和模型的解耦，使代码更易于维护和测试。</p><p>MVC 模式也是一种软件架构设计模式，它将应用程序分为三个部分：模型（Model）、视图（View）和控制器（Controller）。模型负责处理数据和业务逻辑，视图负责显示用户界面，控制器负责接收用户输入并调用模型或视图进行响应。MVC 模式的目的是实现关注点的分离，使代码更具有可扩展性和可复用性。</p><p>MVVM 模式和 MVC 模式的主要区别有：</p><ul><li>MVVM 模式中，视图和模型之间没有直接的联系，而是通过视图模型进行交互。视图模型可以监听模型的变化，并自动更新视图。视图也可以通过命令或事件通知视图模型进行操作。这样实现了双向数据绑定，使得视图和模型保持同步。</li><li>MVC 模式中，视图和模型之间可以有直接的联系，也可以通过控制器进行中介。控制器负责将用户输入转换为对模型或视图的操作。控制器也可以根据模型的变化更新视图。这样实现了单向数据流，使得控制器成为应用程序的核心。</li></ul><p>MVVM 模式适合于需要处理复杂的用户界面和业务逻辑的应用程序，例如桌面应用程序或移动应用程序。MVVM 模式可以利用数据绑定框架或库来简化开发过程，例如 Vue.js, React.js, Angular.js 等。</p>',7),r={href:"http://ASP.NET",target:"_blank",rel:"noopener noreferrer"},u=n('<h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期"><span>生命周期</span></a></h2><h3 id="vue2-的生命周期有哪些" tabindex="-1"><a class="header-anchor" href="#vue2-的生命周期有哪些"><span>Vue2 的生命周期有哪些</span></a></h3><figure><img src="https://cn.vuejs.org/assets/lifecycle_zh-CN.FtDDVyNA.png" alt="组件生命周期图示" tabindex="0" loading="lazy"><figcaption>组件生命周期图示</figcaption></figure><p>Vue 2 的生命周期包含了一系列钩子函数，它们在 Vue 组件实例的不同阶段被调用，允许开发者在特定时刻运行自己的代码。让我简单介绍一下这些生命周期阶段：</p><ol><li><strong>创建阶段</strong>： <ul><li><code>beforeCreate</code>: 在实例初始化之后、数据观测和事件配置之前调用。</li><li><code>created</code>: 在实例创建完成后被调用，此时实例已完成数据观测，但尚未挂载到 DOM 上。</li></ul></li><li><strong>挂载阶段</strong>： <ul><li><code>beforeMount</code>: 在挂载开始之前被调用，此时模板编译已完成，但尚未将组件挂载到 DOM。</li><li><code>mounted</code>: 在实例挂载到 DOM 后被调用，此时组件已经渲染到页面上。</li></ul></li><li><strong>更新阶段</strong>： <ul><li><code>beforeUpdate</code>: 在数据更新之前、DOM 重新渲染之前被调用。</li><li><code>updated</code>: 在数据更新后、DOM 重新渲染之后被调用。</li></ul></li><li><strong>销毁阶段</strong>： <ul><li><code>beforeDestroy</code>: 在实例销毁之前被调用，此时实例仍然完全可用。</li><li><code>destroyed</code>: 在实例销毁后被调用，此时实例已经被销毁，不再可用。</li></ul></li></ol>',5),h={href:"https://cn.vuejs.org/guide/essentials/lifecycle.html",target:"_blank",rel:"noopener noreferrer"},v=n(`<h3 id="keep-alive-中的生命周期有哪些" tabindex="-1"><a class="header-anchor" href="#keep-alive-中的生命周期有哪些"><span>keep-alive 中的生命周期有哪些</span></a></h3><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">activated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在首次挂载、</span>
    <span class="token comment">// 以及每次从缓存中被重新插入的时候调用</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">deactivated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在从 DOM 上移除、进入缓存</span>
    <span class="token comment">// 以及组件卸载时调用</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li><code>activated</code> 在组件挂载时也会调用，并且 <code>deactivated</code> 在组件卸载时也会调用。</li><li>这两个钩子不仅适用于 <code>&lt;KeepAlive&gt;</code> 缓存的根组件，也适用于缓存树中的后代组件。</li></ul></div><h3 id="父子组件生命周期执行顺序" tabindex="-1"><a class="header-anchor" href="#父子组件生命周期执行顺序"><span>父子组件生命周期执行顺序</span></a></h3><ul><li>加载过程：父组件beforeCreate =&gt; 父组件created =&gt; 父组件beforeMount =&gt; 子组件beforeCreate =&gt; 子组件created =&gt; 子组件 beforeMount =&gt; 子组件mounted =&gt; 父组件mounted</li><li>更新过程：父组件beforeUpdate =&gt; 子组件beforeUpdate =&gt; 子组件updated =&gt; 父组件updated</li><li>销毁过程：父组件beforeDestroy =&gt; 子组件 beforeDestroy =&gt; 子组件 destoryed =&gt; 父组件 destoryed</li></ul><h3 id="平时发送异步请求在哪个生命周期-并解释原因" tabindex="-1"><a class="header-anchor" href="#平时发送异步请求在哪个生命周期-并解释原因"><span>平时发送异步请求在哪个生命周期，并解释原因</span></a></h3><ul><li>平时发送异步请求，我一般会在 created 生命周期中调用，因为这样可以更快地获取到服务端的数据，减少页面的 loading 时间，提高用户体验。</li><li>另外，如果我需要进行服务端渲染（SSR），那么在 created 中调用异步请求也有助于保持数据的一致性，因为 SSR 不支持 beforeMount 和 mounted 生命周期。</li><li>当然，如果我需要在异步请求之后进行一些 DOM 操作，那么我也可以在 mounted 生命周期中调用异步请求，但这样可能会导致页面的二次渲染。</li></ul><div class="hint-container tip"><p class="hint-container-title">为什么SSR 不支持 beforeMount 和 mounted 生命周期？</p><p>在服务端渲染（SSR）中，<code>beforeMount</code> 和 <code>mounted</code> 生命周期钩子不被支持的原因是，SSR 主要负责将 Vue 组件渲染成 HTML 字符串，这个过程发生在服务器上，而不是在客户端浏览器中。由于 SSR 只生成 HTML 字符串，它不会创建或操作 DOM，因此没有必要使用与 DOM 相关的生命周期钩子。</p><p>具体来说：</p><ul><li><code>beforeMount</code> 钩子在组件挂载到 DOM 之前被调用，但在 SSR 中，没有 DOM 操作，所以这个钩子不会被执行。</li><li><code>mounted</code> 钩子在组件挂载完成后被调用，通常用于那些需要访问或操作 DOM 的任务。由于 SSR 不涉及 DOM 操作，这个钩子同样不会被执行。</li></ul><p>在 SSR 中，只有 <code>beforeCreate</code> 和 <code>created</code> 这两个生命周期钩子会被调用，因为这些阶段发生在实例初始化过程中，而不涉及 DOM。</p><p>如果你需要在客户端执行与 DOM 相关的操作，可以在 <code>mounted</code> 钩子中进行，这样当应用在客户端激活（hydrate）时，这些操作就会被执行。这也是为什么推荐在 <code>created</code> 钩子中进行数据获取等操作，因为这有助于保持客户端和服务器端代码的一致性。</p></div><h3 id="created-和-mouted-区别" tabindex="-1"><a class="header-anchor" href="#created-和-mouted-区别"><span>created 和 mouted 区别</span></a></h3><p>created 和 mounted 是 Vue.js 中的两个生命周期钩子函数，它们分别用于在 Vue 实例被创建之后和挂载到 DOM 之后执行一些逻辑。具体区别和应用场景如下：</p><ul><li><p>created：</p><ul><li>在 Vue 实例被创建之后立即执行。</li><li>在这个阶段，Vue 实例的数据观测和事件配置已完成，但尚未挂载到 DOM 上。</li><li>通常在这个阶段执行一些数据初始化、事件监听、异步请求等逻辑，但不涉及 DOM 操作。例如，你可以在 created 中发送一个 Ajax 请求来获取数据，并将其赋值给 data 中的属性。</li></ul></li><li><p>mounted：</p><ul><li>在 Vue 实例挂载到 DOM 之后执行。</li><li>在这个阶段，Vue 实例已经完成了数据观测、编译渲染、创建虚拟 DOM 和真实 DOM 等所有过程，可以进行 DOM 操作。</li><li>通常在这个阶段执行一些需要依赖 DOM 元素的逻辑，如获取元素尺寸、绑定事件、设置定时器等。例如，你可以在 mounted 中使用 echarts 来绘制一个图表，并将其插入到某个元素中。</li></ul></li></ul><h2 id="数据绑定" tabindex="-1"><a class="header-anchor" href="#数据绑定"><span>数据绑定</span></a></h2><h3 id="组件中的-data-为什么是一个函数" tabindex="-1"><a class="header-anchor" href="#组件中的-data-为什么是一个函数"><span>组件中的 data 为什么是一个函数？</span></a></h3><p>是为了确保每个组件实例都拥有其自己的数据副本，而不是共享相同的数据。通过将 data 属性设置为函数，每次组件被实例化时，都会调用该函数返回一个新的数据对象，从而避免数据共享和潜在的副作用。</p><h3 id="vue-的双向数据绑定是如何实现的" tabindex="-1"><a class="header-anchor" href="#vue-的双向数据绑定是如何实现的"><span>Vue 的双向数据绑定是如何实现的</span></a></h3><p>Vue 的双向数据绑定是通过<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>来实现的。具体来说，Vue.js 使用了以下几个核心概念来实现双向绑定：</p><ol><li><p><strong>Observer</strong>: 这是一个数据监听器，利用 <code>Object.defineProperty()</code> 方法对属性进行劫持（监听），以便在属性值发生变化时能够得到通知并执行相应的操作。</p></li><li><p><strong>Dep</strong>: 一个消息订阅器，它的主要作用是收集订阅者，并在属性变化时执行订阅者的更新函数。</p></li><li><p><strong>Watcher</strong>: 订阅者，它会在初始化时将自己添加到 Dep 中。当数据变化时，Observer 会通知 Dep，进而触发 Watcher 绑定的更新函数，从而更新视图。</p></li><li><p><strong>Compile</strong>: 解析器，它会解析每个节点元素的相关指令（如 <code>v-model</code>），并初始化一个订阅者 Watcher，替换模板数据或绑定相应的函数。</p></li></ol><p>当数据发生变化时，Observer 会通知 Dep，Dep 会调用 Watcher 的 <code>update</code> 方法，进而更新视图。同时，当用户输入时（如在 <code>input</code> 元素中），视图的变化也会通过 <code>v-model</code> 指令更新数据模型，实现双向绑定。</p><p>这个过程中，Vue.js 的响应式系统会自动追踪依赖关系，确保数据和视图始终保持同步。在 Vue 3 中，这一机制得到了进一步的优化，使用了 Proxy 对象来实现数据的响应式，这比 <code>Object.defineProperty()</code> 方法提供了更好的性能和更多的可能性。</p><h3 id="为什么-vue3-用-proxy-代替了-vue2-中的-object-defineproperty" tabindex="-1"><a class="header-anchor" href="#为什么-vue3-用-proxy-代替了-vue2-中的-object-defineproperty"><span>为什么 Vue3 用 proxy 代替了 Vue2 中的 Object.defineProperty</span></a></h3><p>Vue3 使用 Proxy 替代 Vue2 中的 Object.defineProperty 主要有以下几个原因：</p><ol><li><strong>更全面的监控</strong>：Proxy 可以直接代理整个对象，可以监听对象某个属性值的变化，还可以监听对象属性的新增和删除。而 Object.defineProperty 只能给对象的某个已存在的属性添加对应的 getter 和 setter，所以它只能监听这个属性值的变化，而不能去监听对象属性的新增和删除。</li><li><strong>数组的处理</strong>：在 Vue2 中，由于 Object.defineProperty 只能劫持对象的属性访问，无法直接监测数组的变化，因此需要通过 hack 的方式实现数组的响应式。而 Proxy 在支持对象监测的同时，还支持数组的监听，不再需要额外的操作。</li><li><strong>性能优化</strong>：虽然实际上 Proxy 在性能上是要比 Object.defineProperty 差的，但是 Vue3 对响应式系统进行了重构和优化，采用了基于 Proxy 的 Observation 机制，使访问和修改响应式对象时的性能得到了优化。</li></ol><h3 id="this-set-的用处及用法" tabindex="-1"><a class="header-anchor" href="#this-set-的用处及用法"><span>this.$set() 的用处及用法</span></a></h3><p>在 Vue 中，<code>this.$set()</code> 是一个非常有用的方法，它的主要作用和用法如下：</p><ol><li><p><strong>用途</strong>：当 Vue 的 <code>data</code> 中声明的对象或数组，如果向对象中添加新的属性，更新此属性的值，视图是不会更新的⁵。这是因为 Vue 无法检测到对象属性的添加或删除⁵。在这种情况下，我们就需要使用 <code>this.$set()</code> 进行响应式的数据更新。</p></li><li><p><strong>用法</strong>：<code>this.$set(target, key, value)</code>。</p><ul><li><code>target</code>：要更改的数据源，可以是对象或者数组。</li><li><code>key</code>：要更改或者新增属性的具体数据（对象的 key 为键，数组的 key 为下标）。</li><li><code>value</code>：重新赋的值。</li></ul></li></ol><p>例如，如果你想在 <code>items</code> 数组的第一个位置添加一个新的对象 <code>{ message: &quot;更改one的值&quot;, id: &quot;0&quot; }</code>，你可以这样做：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">&quot;更改one的值&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">&quot;0&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样，<code>items</code> 数组的第一个元素就被成功地更新为新的对象，并且这个变化是响应式的，会触发视图的更新。</p><p>总的来说，<code>this.$set()</code> 是一个非常重要的方法，它能帮助我们解决 Vue 中的一些响应式问题。</p><h3 id="vue-中的数据为什么频繁变化时只会更新一次" tabindex="-1"><a class="header-anchor" href="#vue-中的数据为什么频繁变化时只会更新一次"><span>Vue 中的数据为什么频繁变化时只会更新一次</span></a></h3><p>因为 Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。</p><h3 id="this-nexttick-作用及实现原理" tabindex="-1"><a class="header-anchor" href="#this-nexttick-作用及实现原理"><span>this.$nextTick() 作用及实现原理</span></a></h3><p>Vue.js 在更新 DOM 时，会异步执行更新操作。它内部维护了一个队列，当数据变化时，Vue.js 将组件实例添加到队列中。如果这个实例已经在队列中，那么就跳过，避免重复添加。然后，在下一个事件循环 “tick” 中，Vue.js 刷新队列并执行实际（已去重的）工作。</p><p><code>this.$nextTick()</code> 方法实际上是对这个过程的封装。当你在数据变化之后，使用 <code>this.$nextTick()</code>，则回调函数将在 DOM 更新完成后被调用。</p><h2 id="组件通信" tabindex="-1"><a class="header-anchor" href="#组件通信"><span>组件通信</span></a></h2><h3 id="父子组件通信" tabindex="-1"><a class="header-anchor" href="#父子组件通信"><span>父子组件通信</span></a></h3><h3 id="子组件可以直接改变父组件的值吗" tabindex="-1"><a class="header-anchor" href="#子组件可以直接改变父组件的值吗"><span>子组件可以直接改变父组件的值吗？</span></a></h3><h3 id="平行组件通信" tabindex="-1"><a class="header-anchor" href="#平行组件通信"><span>平行组件通信</span></a></h3><h3 id="什么是状态管理-为什么需要状态管理" tabindex="-1"><a class="header-anchor" href="#什么是状态管理-为什么需要状态管理"><span>什么是状态管理？为什么需要状态管理？</span></a></h3><h3 id="mutations-能不能做异步" tabindex="-1"><a class="header-anchor" href="#mutations-能不能做异步"><span>mutations 能不能做异步</span></a></h3><h3 id="怎么解决刷新页面时-vuex-中数据丢失的问题" tabindex="-1"><a class="header-anchor" href="#怎么解决刷新页面时-vuex-中数据丢失的问题"><span>怎么解决刷新页面时，Vuex 中数据丢失的问题？</span></a></h3><h3 id="vuex-和-localstorage-的区别" tabindex="-1"><a class="header-anchor" href="#vuex-和-localstorage-的区别"><span>Vuex 和 localStorage 的区别</span></a></h3><h2 id="虚拟-dom-和-diff-算法" tabindex="-1"><a class="header-anchor" href="#虚拟-dom-和-diff-算法"><span>虚拟 dom 和 diff 算法</span></a></h2><h3 id="什么是虚拟-dom-有什么用" tabindex="-1"><a class="header-anchor" href="#什么是虚拟-dom-有什么用"><span>什么是虚拟 dom ？有什么用？</span></a></h3><h3 id="虚拟-dom-的解析过程" tabindex="-1"><a class="header-anchor" href="#虚拟-dom-的解析过程"><span>虚拟 dom 的解析过程</span></a></h3><h3 id="diff-算法" tabindex="-1"><a class="header-anchor" href="#diff-算法"><span>diff 算法</span></a></h3><h3 id="vue-中-key-的作用" tabindex="-1"><a class="header-anchor" href="#vue-中-key-的作用"><span>Vue 中 key 的作用</span></a></h3><h3 id="vue2-和-vue3中diff算法的区别" tabindex="-1"><a class="header-anchor" href="#vue2-和-vue3中diff算法的区别"><span>Vue2 和 Vue3中diff算法的区别</span></a></h3><p>Vue2和Vue3的diff算法有一些区别，主要有以下几点：</p><ul><li>Vue2使用双向指针来进行虚拟DOM的比较，而Vue3则使用了单向链表的方式。这样可以减少不必要的比较次数，提高性能。</li></ul><ul><li>在计算key值不同时，Vue2会采用首尾两端比较的方法，而Vue3则采用了更高效的“Map”数据结构。这样可以避免在乱序情况下进行暴力比对，减少移动节点的操作。</li><li>Vue3还对diff算法进行了一些优化，如静态提升、长列表优化、动态组件优化等，可以更好地处理特定的场景，提高应用的性能和响应速度。</li><li>Vue3还增强了异步更新控制，通过更细粒度的控制更新的优先级和批量更新，避免了不必要的更新操作，从而减少了diff算法的运行时间。</li></ul><h2 id="vue2-和-vue3的区别" tabindex="-1"><a class="header-anchor" href="#vue2-和-vue3的区别"><span>Vue2 和 Vue3的区别</span></a></h2><h3 id="生命周期-1" tabindex="-1"><a class="header-anchor" href="#生命周期-1"><span>生命周期</span></a></h3><h3 id="diff-算法-1" tabindex="-1"><a class="header-anchor" href="#diff-算法-1"><span>diff 算法</span></a></h3><h3 id="数据响应式原理" tabindex="-1"><a class="header-anchor" href="#数据响应式原理"><span>数据响应式原理</span></a></h3><h3 id="组件通信-1" tabindex="-1"><a class="header-anchor" href="#组件通信-1"><span>组件通信</span></a></h3><h2 id="标签和属性" tabindex="-1"><a class="header-anchor" href="#标签和属性"><span>标签和属性</span></a></h2><h3 id="v-if-和-v-show-的区别" tabindex="-1"><a class="header-anchor" href="#v-if-和-v-show-的区别"><span>v-if 和 v-show 的区别</span></a></h3><h3 id="v-if-和-v-for-哪个优先级更高" tabindex="-1"><a class="header-anchor" href="#v-if-和-v-for-哪个优先级更高"><span>v-if 和 v-for 哪个优先级更高</span></a></h3><h3 id="slot-插槽-的作用" tabindex="-1"><a class="header-anchor" href="#slot-插槽-的作用"><span>slot（插槽）的作用</span></a></h3><h3 id="computed-计算属性-和-watch-监听属性-的区别" tabindex="-1"><a class="header-anchor" href="#computed-计算属性-和-watch-监听属性-的区别"><span>computed（计算属性）和 watch（监听属性）的区别</span></a></h3><h2 id="路由" tabindex="-1"><a class="header-anchor" href="#路由"><span>路由</span></a></h2><h3 id="vue-实现路由跳转的方法" tabindex="-1"><a class="header-anchor" href="#vue-实现路由跳转的方法"><span>Vue 实现路由跳转的方法</span></a></h3><h3 id="路由的-hash-模式和-history-模式的区别" tabindex="-1"><a class="header-anchor" href="#路由的-hash-模式和-history-模式的区别"><span>路由的 hash 模式和 history 模式的区别</span></a></h3><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><h3 id="vue-如何实现响应式" tabindex="-1"><a class="header-anchor" href="#vue-如何实现响应式"><span>vue 如何实现响应式</span></a></h3><p>Vue是采用数据劫持结合发布者-订阅者模式的方式, Vue相应系统有三大核心：observe,dep,watcher;</p><ul><li>Observe：当一个Vue实例创建时，initData阶段，vue会遍历data选项的属性（observe），用 Object.defineProperty 将它们转为 getter/setter并且在内部追踪相关依赖(dep)，在属性被访问和修改时通知变化。</li><li>Compite：调用compile方法解析模版,当视图中有用到vue.data中数据的时候，会调用实例化watcher方法进行依赖收集</li><li>Watcher：是Observer和Compile之间通信的桥梁，当视图中遇到绑定的数据时,在watcher方法中会获取这个数据，此时会触发observe中的getter方法</li><li>Dep：发布订阅模式,observe中数据的getter被触发时会收集依watcher(dep.depend方法)</li><li>当有数据被改动时会触发observe中数据的setter，此时会调用dep.notify方法给所有订阅的watcher发通知（通过回掉方式）进行视图更新，此</li></ul><h3 id="nexttick" tabindex="-1"><a class="header-anchor" href="#nexttick"><span>$nextTick</span></a></h3>`,69),k={href:"https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js#L42",target:"_blank",rel:"noopener noreferrer"},m=n(`<ul><li>首先会将所有的nextTick放到一个函数中，然后放在callbacks数组中，$nextTick没有传cb回调，则返回一个promise</li><li>接下来就是callbacks的执行时机 <ul><li>首先如果浏览器是否兼容promise，则用promise.resolve().then来执行callbacks</li><li>如果浏览器兼容MutationObserver,则用实例化的MutationObserver监听文本变化来执行回调</li><li>如果兼容setImmediate,则用setImmediate(cb)来执行回掉<br> 最后降级为用setTimeout(fn,0)来执行</li><li>在vue2.5.X版本中对于像v-on这样的DOM交互事件，默认走macroTimerFunc，也就是，跳过第一步promise的判断</li></ul></li></ul><h3 id="computed" tabindex="-1"><a class="header-anchor" href="#computed"><span>Computed</span></a></h3><ul><li>vue对象初始化的同时对计算属性进行初始化initComputed</li><li>computed会初始化Watcher实例，并在内实例化一个Dep消息订阅器用作后续收集依赖</li><li>当视图中有对computed引用的时候会第一次执行计算属性，调用watcher的evaluate方法，将dirty设置为false,并将结果保存在this.value中进行缓存</li><li>如果依赖没有更改，则下次获取computed会这直接返回this.value<br> 当computed所依赖的属性发生变化时会调用watcher的update方法将dirty设置为true，下次调用computed时就会重新计算</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Watcher</span><span class="token punctuation">{</span>
  ……
  <span class="token function">evaluate</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>dirty <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
  ……
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">initComputed</span><span class="token punctuation">{</span>
  …… 
  <span class="token comment">//计算属性的getter 获取计算属性的值时会调用</span>
	<span class="token function">createComputedGetter</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">computedGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  	<span class="token comment">//获取到相应的watcher</span>
	    <span class="token keyword">const</span> watcher <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_computedWatchers <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_computedWatchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    	 <span class="token comment">//watcher.dirty 参数决定了计算属性值是否需要重新计算，默认值为true，即第一次时会调用一次</span>
	      	<span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span>dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	      		<span class="token comment">/*每次执行之后watcher.dirty会设置为false，只要依赖的data值改变时才会触发
	      		watcher.dirty为true,从而获取值时从新计算*/</span>
	        	watcher<span class="token punctuation">.</span><span class="token function">evaluate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	      	<span class="token punctuation">}</span>
	      	<span class="token comment">//获取依赖</span>
	      	<span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	        	watcher<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	      	<span class="token punctuation">}</span>
	      	<span class="token comment">//返回计算属性的值</span>
	      	<span class="token keyword">return</span> watcher<span class="token punctuation">.</span>value
	    <span class="token punctuation">}</span>
	  <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
  ……
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="watch" tabindex="-1"><a class="header-anchor" href="#watch"><span>watch</span></a></h3><h2 id="开放性问题" tabindex="-1"><a class="header-anchor" href="#开放性问题"><span>开放性问题</span></a></h2><h3 id="说说-vue-的优缺点" tabindex="-1"><a class="header-anchor" href="#说说-vue-的优缺点"><span>说说 Vue 的优缺点</span></a></h3><h3 id="vue-模板编译原理" tabindex="-1"><a class="header-anchor" href="#vue-模板编译原理"><span>Vue 模板编译原理</span></a></h3><h3 id="说一说-vue-的性能优化" tabindex="-1"><a class="header-anchor" href="#说一说-vue-的性能优化"><span>说一说 Vue 的性能优化</span></a></h3><p>Vue 的性能优化是一个很重要的话题，它涉及到 Vue 应用的页面加载速度和更新速度两个方面。为了提高 Vue 的性能，我们可以从以下几个方面进行优化：</p><ul><li>代码优化：我们可以通过以下方法来减少代码量和提高代码质量： <ul><li>使用模块化和组件化的方式来组织代码，避免重复和冗余的代码，提高代码的复用性和可维护性。</li><li>使用 v-if 和 v-for 时注意避免不必要的渲染，给每个 v-for 的元素设置唯一的 key 值，提高 diff 算法的效率。</li><li>使用 computed 属性和 watch 选项来优化数据的计算和监听，避免在模板中使用复杂的表达式和过滤器。</li><li>使用事件代理的方式来处理多个元素的事件绑定，减少事件监听器的数量。</li><li>使用 keep-alive 组件来缓存不活动的组件，避免重复渲染。</li><li>使用异步组件和路由懒加载的方式来实现按需加载，减少首屏加载时间。</li><li>使用自定义指令和插件来封装常用的功能，提高代码的可读性和可扩展性。</li></ul></li><li>资源优化：我们可以通过以下方法来压缩和优化静态资源，如图片、字体、CSS 和 JS 文件： <ul><li>使用 Webpack 等打包工具来进行代码压缩、Tree-shaking、Scope Hoisting 等优化操作，减少打包后的文件体积。</li><li>使用 CDN 来存储和分发静态资源，提高资源的加载速度和可用性。</li><li>使用图片懒加载的方式来延迟加载图片，减少网络请求和内存占用。</li><li>使用 SVG 图标来替代图片图标，提高图标的清晰度和灵活性。</li><li>使用字体子集或 Web 字体加载器来优化字体文件的加载，减少字体文件的体积和阻塞时间。</li></ul></li><li>架构优化：我们可以根据应用的类型和需求来选择合适的架构方式，如 SSR、SSG、SPA 等，以提高应用的页面加载速度和用户体验： <ul><li>如果应用对 SEO 和首屏加载性能有较高的要求，可以使用 SSR（服务器端渲染）或 SSG（静态站点生成）的方式来直接返回包含内容的 HTML 代码，避免客户端渲染带来的额外开销。</li><li>如果应用对交互性和动态性有较高的要求，可以使用 SPA（单页应用）的方式来实现客户端渲染，提高应用的响应速度和灵活性。</li><li>如果应用既需要 SEO 和首屏加载性能，又需要交互性和动态性，可以使用 SSR + SPA 的混合模式，或者使用预渲染、骨架屏等技术来提升用户体验。</li></ul></li></ul>`,11);function f(b,g){const s=i("ExternalLinkIcon");return o(),c("div",null,[d,a("p",null,[e("MVC 模式适合于需要快速开发和部署的应用程序，例如 Web 应用程序或服务端应用程序。MVC 模式可以利用 Web 开发框架或工具来提高开发效率，例如 Spring MVC, "),a("a",r,[e("ASP.NET"),t(s)]),e(" MVC, Zend Framework, JSF 等。")]),u,a("p",null,[e("这些生命周期钩子允许你在不同的阶段执行自定义逻辑，比如初始化数据、访问 DOM 元素、清理资源等。详细了解每个钩子的用法可以参考 "),a("a",h,[e("Vue.js 官方文档"),t(s)])]),v,a("p",null,[e("vue实现响应式并不是数据一更新就立刻触发dom变化，而是按照一定的策略对dom进行更新，"),a("a",k,[e("源码位置"),t(s)]),e("，原理：")]),m])}const y=l(p,[["render",f],["__file","Vue.html.vue"]]),M=JSON.parse('{"path":"/%E9%9D%A2%E8%AF%95/Vue.html","title":"Vue","lang":"zh-CN","frontmatter":{"title":"Vue","icon":"vue","date":"2023-05-22T00:00:00.000Z","order":4,"category":["面试"],"tag":["Vue"],"description":"Vue 的设计模式 介绍一下 MVVM 模式和 MVC 模式有什么区别？ MVVM 模式是一种软件架构设计模式，它将应用程序分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。模型负责处理数据和业务逻辑，视图负责显示用户界面，视图模型负责连接视图和模型，并实现数据绑定和命令模式。MVVM 模式的目的是实现视图和模型的解耦...","head":[["meta",{"property":"og:url","content":"https://godx-18.github.io/%E9%9D%A2%E8%AF%95/Vue.html"}],["meta",{"property":"og:site_name","content":"烜"}],["meta",{"property":"og:title","content":"Vue"}],["meta",{"property":"og:description","content":"Vue 的设计模式 介绍一下 MVVM 模式和 MVC 模式有什么区别？ MVVM 模式是一种软件架构设计模式，它将应用程序分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。模型负责处理数据和业务逻辑，视图负责显示用户界面，视图模型负责连接视图和模型，并实现数据绑定和命令模式。MVVM 模式的目的是实现视图和模型的解耦..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cn.vuejs.org/assets/lifecycle_zh-CN.FtDDVyNA.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-14T07:18:18.000Z"}],["meta",{"property":"article:author","content":"GodX"}],["meta",{"property":"article:tag","content":"Vue"}],["meta",{"property":"article:published_time","content":"2023-05-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-14T07:18:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vue\\",\\"image\\":[\\"https://cn.vuejs.org/assets/lifecycle_zh-CN.FtDDVyNA.png\\"],\\"datePublished\\":\\"2023-05-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-14T07:18:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"GodX\\",\\"url\\":\\"https://github.com/GodX-18\\"}]}"]]},"headers":[{"level":2,"title":"Vue 的设计模式","slug":"vue-的设计模式","link":"#vue-的设计模式","children":[{"level":3,"title":"介绍一下 MVVM 模式和 MVC 模式有什么区别？","slug":"介绍一下-mvvm-模式和-mvc-模式有什么区别","link":"#介绍一下-mvvm-模式和-mvc-模式有什么区别","children":[]}]},{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[{"level":3,"title":"Vue2 的生命周期有哪些","slug":"vue2-的生命周期有哪些","link":"#vue2-的生命周期有哪些","children":[]},{"level":3,"title":"keep-alive 中的生命周期有哪些","slug":"keep-alive-中的生命周期有哪些","link":"#keep-alive-中的生命周期有哪些","children":[]},{"level":3,"title":"父子组件生命周期执行顺序","slug":"父子组件生命周期执行顺序","link":"#父子组件生命周期执行顺序","children":[]},{"level":3,"title":"平时发送异步请求在哪个生命周期，并解释原因","slug":"平时发送异步请求在哪个生命周期-并解释原因","link":"#平时发送异步请求在哪个生命周期-并解释原因","children":[]},{"level":3,"title":"created 和 mouted 区别","slug":"created-和-mouted-区别","link":"#created-和-mouted-区别","children":[]}]},{"level":2,"title":"数据绑定","slug":"数据绑定","link":"#数据绑定","children":[{"level":3,"title":"组件中的 data 为什么是一个函数？","slug":"组件中的-data-为什么是一个函数","link":"#组件中的-data-为什么是一个函数","children":[]},{"level":3,"title":"Vue 的双向数据绑定是如何实现的","slug":"vue-的双向数据绑定是如何实现的","link":"#vue-的双向数据绑定是如何实现的","children":[]},{"level":3,"title":"为什么 Vue3 用 proxy 代替了 Vue2 中的 Object.defineProperty","slug":"为什么-vue3-用-proxy-代替了-vue2-中的-object-defineproperty","link":"#为什么-vue3-用-proxy-代替了-vue2-中的-object-defineproperty","children":[]},{"level":3,"title":"this.$set() 的用处及用法","slug":"this-set-的用处及用法","link":"#this-set-的用处及用法","children":[]},{"level":3,"title":"Vue 中的数据为什么频繁变化时只会更新一次","slug":"vue-中的数据为什么频繁变化时只会更新一次","link":"#vue-中的数据为什么频繁变化时只会更新一次","children":[]},{"level":3,"title":"this.$nextTick() 作用及实现原理","slug":"this-nexttick-作用及实现原理","link":"#this-nexttick-作用及实现原理","children":[]}]},{"level":2,"title":"组件通信","slug":"组件通信","link":"#组件通信","children":[{"level":3,"title":"父子组件通信","slug":"父子组件通信","link":"#父子组件通信","children":[]},{"level":3,"title":"子组件可以直接改变父组件的值吗？","slug":"子组件可以直接改变父组件的值吗","link":"#子组件可以直接改变父组件的值吗","children":[]},{"level":3,"title":"平行组件通信","slug":"平行组件通信","link":"#平行组件通信","children":[]},{"level":3,"title":"什么是状态管理？为什么需要状态管理？","slug":"什么是状态管理-为什么需要状态管理","link":"#什么是状态管理-为什么需要状态管理","children":[]},{"level":3,"title":"mutations 能不能做异步","slug":"mutations-能不能做异步","link":"#mutations-能不能做异步","children":[]},{"level":3,"title":"怎么解决刷新页面时，Vuex 中数据丢失的问题？","slug":"怎么解决刷新页面时-vuex-中数据丢失的问题","link":"#怎么解决刷新页面时-vuex-中数据丢失的问题","children":[]},{"level":3,"title":"Vuex 和 localStorage 的区别","slug":"vuex-和-localstorage-的区别","link":"#vuex-和-localstorage-的区别","children":[]}]},{"level":2,"title":"虚拟 dom 和 diff 算法","slug":"虚拟-dom-和-diff-算法","link":"#虚拟-dom-和-diff-算法","children":[{"level":3,"title":"什么是虚拟 dom ？有什么用？","slug":"什么是虚拟-dom-有什么用","link":"#什么是虚拟-dom-有什么用","children":[]},{"level":3,"title":"虚拟 dom 的解析过程","slug":"虚拟-dom-的解析过程","link":"#虚拟-dom-的解析过程","children":[]},{"level":3,"title":"diff 算法","slug":"diff-算法","link":"#diff-算法","children":[]},{"level":3,"title":"Vue 中 key 的作用","slug":"vue-中-key-的作用","link":"#vue-中-key-的作用","children":[]},{"level":3,"title":"Vue2 和 Vue3中diff算法的区别","slug":"vue2-和-vue3中diff算法的区别","link":"#vue2-和-vue3中diff算法的区别","children":[]}]},{"level":2,"title":"Vue2 和 Vue3的区别","slug":"vue2-和-vue3的区别","link":"#vue2-和-vue3的区别","children":[{"level":3,"title":"生命周期","slug":"生命周期-1","link":"#生命周期-1","children":[]},{"level":3,"title":"diff 算法","slug":"diff-算法-1","link":"#diff-算法-1","children":[]},{"level":3,"title":"数据响应式原理","slug":"数据响应式原理","link":"#数据响应式原理","children":[]},{"level":3,"title":"组件通信","slug":"组件通信-1","link":"#组件通信-1","children":[]}]},{"level":2,"title":"标签和属性","slug":"标签和属性","link":"#标签和属性","children":[{"level":3,"title":"v-if 和 v-show 的区别","slug":"v-if-和-v-show-的区别","link":"#v-if-和-v-show-的区别","children":[]},{"level":3,"title":"v-if 和 v-for 哪个优先级更高","slug":"v-if-和-v-for-哪个优先级更高","link":"#v-if-和-v-for-哪个优先级更高","children":[]},{"level":3,"title":"slot（插槽）的作用","slug":"slot-插槽-的作用","link":"#slot-插槽-的作用","children":[]},{"level":3,"title":"computed（计算属性）和 watch（监听属性）的区别","slug":"computed-计算属性-和-watch-监听属性-的区别","link":"#computed-计算属性-和-watch-监听属性-的区别","children":[]}]},{"level":2,"title":"路由","slug":"路由","link":"#路由","children":[{"level":3,"title":"Vue 实现路由跳转的方法","slug":"vue-实现路由跳转的方法","link":"#vue-实现路由跳转的方法","children":[]},{"level":3,"title":"路由的 hash 模式和 history 模式的区别","slug":"路由的-hash-模式和-history-模式的区别","link":"#路由的-hash-模式和-history-模式的区别","children":[]}]},{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[{"level":3,"title":"vue 如何实现响应式","slug":"vue-如何实现响应式","link":"#vue-如何实现响应式","children":[]},{"level":3,"title":"$nextTick","slug":"nexttick","link":"#nexttick","children":[]},{"level":3,"title":"Computed","slug":"computed","link":"#computed","children":[]},{"level":3,"title":"watch","slug":"watch","link":"#watch","children":[]}]},{"level":2,"title":"开放性问题","slug":"开放性问题","link":"#开放性问题","children":[{"level":3,"title":"说说 Vue 的优缺点","slug":"说说-vue-的优缺点","link":"#说说-vue-的优缺点","children":[]},{"level":3,"title":"Vue 模板编译原理","slug":"vue-模板编译原理","link":"#vue-模板编译原理","children":[]},{"level":3,"title":"说一说 Vue 的性能优化","slug":"说一说-vue-的性能优化","link":"#说一说-vue-的性能优化","children":[]}]}],"git":{"createdTime":1684735463000,"updatedTime":1713079098000,"contributors":[{"name":"GodX","email":"1046529973@qq.com","commits":5}]},"readingTime":{"minutes":17.84,"words":5353},"filePathRelative":"面试/Vue.md","localizedDate":"2023年5月22日","excerpt":"<h2>Vue 的设计模式</h2>\\n<h3>介绍一下 MVVM 模式和 MVC 模式有什么区别？</h3>\\n<p>MVVM 模式是一种软件架构设计模式，它将应用程序分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。模型负责处理数据和业务逻辑，视图负责显示用户界面，视图模型负责连接视图和模型，并实现数据绑定和命令模式。MVVM 模式的目的是实现视图和模型的解耦，使代码更易于维护和测试。</p>\\n<p>MVC 模式也是一种软件架构设计模式，它将应用程序分为三个部分：模型（Model）、视图（View）和控制器（Controller）。模型负责处理数据和业务逻辑，视图负责显示用户界面，控制器负责接收用户输入并调用模型或视图进行响应。MVC 模式的目的是实现关注点的分离，使代码更具有可扩展性和可复用性。</p>","autoDesc":true}');export{y as comp,M as data};
