---
title: 案例
date: 2024-03-18
order: 2
category:
  - 算法
tag:
  - 数
---
## [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)(简)

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

**示例 2：**

```
输入：root = [1,null,2]
输出：2 
```

**提示：**

- 树中节点的数量在 `[0, 104]` 区间内。
- `-100 <= Node.val <= 100`

:::tip 解题思路

**方法一：后序遍历**

* 终止条件： 当 root 为空，说明已越过叶节点，因此返回 深度 000 。
* 递推工作： 本质上是对树做后序遍历。
  * 计算节点 root 的 左子树的深度 ，即调用 maxDepth(root.left)。
  * 计算节点 root 的 右子树的深度 ，即调用 maxDepth(root.right)。
* 返回值： 返回 此树的深度 ，即 max(maxDepth(root.left), maxDepth(root.right)) + 1

**方法二：层序遍历**

树的层序遍历 / 广度优先搜索往往利用 队列 实现。

关键点： 每遍历一层，则计数器 +1+1+1 ，直到遍历完成，则可得到树的深度。

* 特例处理： 当 root 为空，直接返回 深度 000 。
* 初始化： 队列 queue （加入根节点 root ），计数器 res = 0。
* 循环遍历： 当 queue 为空时跳出。
  * 初始化一个空列表 tmp ，用于临时存储下一层节点。
  * 遍历队列： 遍历 queue 中的各节点 node ，并将其左子节点和右子节点加入 tmp。
  * 更新队列： 执行 queue = tmp ，将下一层节点赋值给 queue。
  * 统计层数： 执行 res += 1 ，代表层数加 1。
* 返回值： 返回 res 即可。

:::

:::code-tabs#shell

@tab 后序遍历

```js
var maxDepth = function (root) {
    if(!root) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
};
```

@tab 层序遍历

```js
var maxDepth = function (root) {
    if(!root) return 0;
    let res = 0;
    let queue = [];
    queue.push(root);
    while(queue.length) {
        let temp = [];
        for(let node of queue) {
            node.left && temp.push(node.left);
            node.right && temp.push(node.right);
        }
        queue = temp;
        res++
    }
    return res
};
```

:::
